resultados_mod$row_names <- resultados_ensembl_id$symbol[index]
# Resultado final
print(resultados_mod)
############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)
# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)
#Variável
my_genes = resultados_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(ensgene, symbol)
# Print the filtered table
print(resultados_id)
resultados_id = as.data.frame(resultados_id)
resultados_ensembl_id
############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)
# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)
#Variável
my_genes = resultados_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(ensgene, symbol)
# Print the filtered table
print(resultados_id)
resultados_id = as.data.frame(resultados_id)
resultados_ensembl_id
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)
# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)
#Variável
my_genes = resultados_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(ensgene, symbol)
# Print the filtered table
print(resultados_id)
resultados_id = as.data.frame(resultados_id)
resultados_ensembl_id
############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)
# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)
#Variável
my_genes = resultados_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(ensgene, symbol)
# Print the filtered table
print(resultados_id)
resultados_id = as.data.frame(resultados_id)
resultados_ensembl_id
############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)
# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)
print(resultados_mod)
#Variável
my_genes = resultados_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(ensgene, symbol)
# Print the filtered table
print(resultados_id)
resultados_id = as.data.frame(resultados_id)
resultados_ensembl_id
# Substitua os IDs do Ensembl pelos IDs de genes correspondentes
resultados_mod$row_names <- resultados_ensembl_id$symbol[index]
# Resultado final
print(resultados_mod)
View(resultados_ensembl_id)
View(resultados_id)
View(resultados_mod)
## Substituir os valores na segunda coluna do dataframe original pelos correspondentes do segundo dataframe
resultados_mod$symbol <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), df_ensembl$ensgene)]
## Substituir os valores na segunda coluna do dataframe original pelos correspondentes do segundo dataframe
resultados_mod$symbol <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
# Remover a coluna 'row_names' se não for mais necessária
resultados_mod <- resultados_mod[, -1]
# Resultado final
print(resultados_mod)
## Substituir os valores na segunda coluna do dataframe original pelos correspondentes do segundo dataframe
resultados_mod$row_names <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
## Substituir os valores na segunda coluna do dataframe original pelos correspondentes do segundo dataframe
resultados_mod$symbol <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
## Substituir os valores na segunda coluna do dataframe original pelos correspondentes do segundo dataframe
resultados_mod$row_names = resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
# Substituir os valores na segunda coluna do dataframe original pelos correspondentes do segundo dataframe
resultados_mod$row_names <- df_ensembl$symbol[match(gsub("\\..*", "", resultados_mod$row_names), df_ensembl$ensgene)]
# Substituir os valores na segunda coluna do dataframe original pelos correspondentes do segundo dataframe
resultados_mod$row_names <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
# Substituir os nomes das colunas "row_names" do dataframe "resultados_mod" pelos valores correspondentes da coluna "symbol" do dataframe "resultados_ensembl_id"
resultados_mod$row_names <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)
# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)
print(resultados_mod)
#Variável
my_genes = resultados_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(ensgene, symbol)
# Print the filtered table
print(resultados_id)
resultados_id = as.data.frame(resultados_id)
resultados_ensembl_id
# Substituir os nomes das colunas "row_names" do dataframe "resultados_mod" pelos valores correspondentes da coluna "symbol" do dataframe "resultados_ensembl_id"
resultados_mod$row_names <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
# Resultado final
print(resultados_mod)
View(resultados_mod)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
View(results)
View(results.ord)
View(resultados_mod)
View(resultados_id)
# Remover a coluna com os nomes das linhas no dataframe
resultados_mod <- resultados_mod[, -1]
# Resultado final
print(resultados_mod)
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)
# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)
print(resultados_mod)
#Variável
my_genes = resultados_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(ensgene, symbol)
# Print the filtered table
print(resultados_id)
resultados_id = as.data.frame(resultados_id)
resultados_ensembl_id
# Substituir os nomes das colunas "row_names" do dataframe "resultados_mod" pelos valores correspondentes da coluna "symbol" do dataframe "resultados_ensembl_id"
resultados_mod$row_names <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
# Resultado final
print(resultados_mod)
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
library(dplyr)
# Definir a primeira coluna como os nomes das linhas
rownames(resultados_mod) <- resultados_mod[, 1]
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
# Verificar se há duplicatas nos valores que deseja usar como nomes das linhas
if (anyDuplicated(resultados_mod[, 1]) == 0) {
# Definir a primeira coluna como os nomes das linhas
rownames(resultados_mod) <- resultados_mod[, 1]
# Remover a primeira coluna do dataframe
resultados_mod <- resultados_mod[, -1]
# Resultado final
print(resultados_mod)
} else {
print("Existem valores duplicados que estão sendo usados como nomes das linhas.")
}
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
# Verificar se há duplicatas nos valores que deseja usar como nomes das linhas
if (anyDuplicated(resultados_mod[, 1]) > 0) {
# Remover as linhas duplicadas
resultados_mod <- unique(resultados_mod)
}
# Definir a primeira coluna como os nomes das linhas
rownames(resultados_mod) <- resultados_mod[, 1]
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
# Remover as linhas duplicadas
resultados_mod <- unique(resultados_mod)
# Definir a primeira coluna como os nomes das linhas
rownames(resultados_mod) <- resultados_mod[, 1]
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
# Remover as linhas duplicadas
resultados_mod <- unique(resultados_mod)
# Criar um vetor de nomes de linha únicos
unique_row_names <- paste0("Row_", seq_len(nrow(resultados_mod)))
# Definir os nomes das linhas
rownames(resultados_mod) <- unique_row_names
# Resultado final
print(resultados_mod)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
ranks
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
# Extrair os IDs dos genes do dataframe resultados_mod
gene_ids <- resultados_mod$row_names
# Substituir os valores em ranks pelos IDs dos genes
ranks_ids <- gene_ids[as.character(names(ranks))]
# Resultado final
print(ranks_ids)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
# Extrair os IDs dos genes do dataframe resultados_mod
gene_ids <- resultados_mod$row_names
# Substituir os valores em ranks pelos IDs dos genes
ranks_ids <- gene_ids[(names(ranks))]
# Resultado final
print(ranks_ids)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- results.ord$row_names
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
fgseaRes <- fgsea(pathways = bg_genes, ranks, minSize=10, maxSize = 1000)
fgseaRes <- fgsea(pathways = bg_genes,
stats = ranks,
scoreType = 'std',
minSize=10,
maxSize = 1000)
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking <- max(rans[is.finite(ranks)])
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking <- max(ranks[is.finite(ranks)])
min_ranking <- min(rankings[is.finite(rankings)])
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking <- max(ranks[is.finite(ranks)])
min_ranking <- min(ranks[is.finite(ranks)])
rankings <- replace(ranks, ranks > max_ranking, max_ranking * 10)
rankings <- replace(ranks, ranks < min_ranking, min_ranking * 10)
rankings <- sort(ranks, decreasing = TRUE) # sort genes by ranking
fgseaRes <- fgsea(pathways = bg_genes,
stats = ranks,
scoreType = 'std',
minSize=10,
maxSize = 1000)
fgseaRes <- fgsea(pathways = bg_genes,
stats = rankings,
scoreType = 'std',
minSize=10,
maxSize = 1000)
class(fgseaRes)
dim(fgseaRes)
head(fgseaRes[order(padj), ])
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
matrix_to_list <- function(pws){
pws.l <- list()
for (pw in colnames(pws)) {
pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
}
return(pws.l)
}
## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE){
# for debug
#file <- gmt_files[1]
#genes_in_data <- df$gene_symbol
# Read in gmt file
gmt <- gmtPathways(gmt_file)
hidden <- unique(unlist(gmt))
# Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
mat <- matrix(NA, dimnames = list(hidden, names(gmt)),
nrow = length(hidden), ncol = length(gmt))
for (i in 1:dim(mat)[2]){
mat[,i] <- as.numeric(hidden %in% gmt[[i]])
}
#Subset to the genes that are present in our data to avoid bias
hidden1 <- intersect(genes_in_data, hidden)
mat <- mat[hidden1, colnames(mat)[which(colSums(mat[hidden1,])>5)]] # filter for gene sets with more than 5 genes annotated
# And get the list again
final_list <- matrix_to_list(mat) # for this we use the function we previously defined
if(savefile){
saveRDS(final_list, file = paste0(gsub('.gmt', '', gmt_file), '_subset_', format(Sys.time(), '%d%m'), '.RData'))
}
print('Wohoo! .gmt conversion successfull!:)')
return(final_list)
}
############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)
# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)
print(resultados_mod)
#Variável
my_genes = resultados_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id <- grch38 %>%
filter(ensgene %in% resultados_mod$row_names) %>%
# Select only the 'entrez' column
select(ensgene, symbol)
# Print the filtered table
print(resultados_id)
resultados_id = as.data.frame(resultados_id)
resultados_ensembl_id
# Substituir os nomes das colunas "row_names" do dataframe "resultados_mod" pelos valores correspondentes da coluna "symbol" do dataframe "resultados_ensembl_id"
resultados_mod$row_names <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]
# Resultado final
print(resultados_mod)
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL
# Resultado final
print(resultados_mod)
results.ord <- resultados_mod[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- results.ord$row_names
head(ranks)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)
barplot(ranks)
vector = unlist(resultados_id)
#Carregar ficheiro gmt
bg_genes = prepare_gmt("C:\\Users\\olive\\Desktop\\Extracao\\c2.cp.v2023.2.Hs.symbols.gmt", vector, savefile = FALSE)
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking <- max(ranks[is.finite(ranks)])
min_ranking <- min(ranks[is.finite(ranks)])
rankings <- replace(ranks, ranks > max_ranking, max_ranking * 10)
rankings <- replace(ranks, ranks < min_ranking, min_ranking * 10)
rankings <- sort(ranks, decreasing = TRUE) # sort genes by ranking
fgseaRes <- fgsea(pathways = bg_genes,
stats = rankings,
scoreType = 'std',
minSize=10,
maxSize = 1000)
class(fgseaRes)
dim(fgseaRes)
head(fgseaRes[order(padj), ])
View(resultados_id)
View(resultados_mod)
