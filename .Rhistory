ColSideColors=col.cell1,scale="row",
margins = c(10, 12))
# Adicione a legenda na parte inferior esquerda
legend("toleft", legend=labels, fill=c("purple","orange","green"))
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 30 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:30]
select_var
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
# Criação do mapa dos 30 genes mais variáveis entre todas as amostras
mypalette = brewer.pal(9,"RdYlBu")
morecols = colorRampPalette(mypalette)
labels = levels(meta$expr)
col.cell1 = c("purple","orange", "green")[meta$expr]
heatmap.2(highly_variable_lcpm,
col=rev(morecols(50)),
trace="column",
main="Top 30 genes mais variáveis",
ColSideColors=col.cell1,scale="row",
margins = c(10, 12))
# Adicione a legenda na parte inferior esquerda
legend("topleft", legend=labels, fill=c("purple","orange","green"))
# Criação do mapa dos 30 genes mais variáveis entre 50 amostras
labels = levels(meta$expr)
col.cell2 = c("purple","orange", "green")[meta$expr][1:50]
heatmap.2(highly_variable_lcpm[,1:50],
col=rev(morecols(50)),
trace="column",
main="Top 30 genes mais variáveis entre 50 amostras aleatórias",
ColSideColors=col.cell2,scale="row",
margins = c(5, 12))
legend("bottomleft", legend=labels, fill=c("purple","orange","green"))
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 30 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:30]
select_var
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
# Criação do mapa dos 30 genes mais variáveis entre todas as amostras
mypalette = brewer.pal(9,"RdYlBu")
morecols = colorRampPalette(mypalette)
labels = levels(meta$expr)
col.cell1 = c("purple","orange", "green")[meta$expr]
heatmap.2(highly_variable_lcpm,
col=rev(morecols(50)),
trace="column",
main="Top 30 genes mais variáveis",
ColSideColors=col.cell1,scale="row",
margins = c(5, 12))
legend("topleft", legend=labels, fill=c("purple","orange","green"))
# Criação do mapa dos 30 genes mais variáveis entre 50 amostras
labels = levels(meta$expr)
col.cell2 = c("purple","orange", "green")[meta$expr][1:50]
heatmap.2(highly_variable_lcpm[,1:50],
col=rev(morecols(50)),
trace="column",
main="Top 30 genes mais variáveis entre 50 amostras aleatórias",
ColSideColors=col.cell2,scale="row",
margins = c(5, 12))
legend("bottomleft", legend=labels, fill=c("purple","orange","green"))
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 30 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:30]
select_var
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
# Criação do mapa dos 30 genes mais variáveis entre todas as amostras
mypalette = brewer.pal(9,"RdYlBu")
morecols = colorRampPalette(mypalette)
labels = levels(meta$expr)
col.cell1 = c("purple","orange", "green")[meta$expr]
heatmap.2(highly_variable_lcpm,
col=rev(morecols(50)),
trace="column",
main="Top 30 genes mais variáveis",
ColSideColors=col.cell1,scale="row",
margins = c(5, 12))
legend("topleft", legend=labels, fill=c("purple","orange","green"))
# Criação do mapa dos 30 genes mais variáveis entre 50 amostras
labels = levels(meta$expr)
col.cell2 = c("purple","orange", "green")[meta$expr][1:50]
heatmap.2(highly_variable_lcpm[,1:50],
col=rev(morecols(50)),
trace="column",
main="Top 30 genes mais variáveis entre 50 amostras aleatórias",
ColSideColors=col.cell2,scale="row",
margins = c(5, 12))
legend("bottomleft", legend=labels, fill=c("purple","orange","green"))
dgeObj = calcNormFactors(dgeObj)
>>>>>>> clustering
plotMD(logcounts, column = 7)
abline(h=0,col="grey")
plotMD(dgeObj, column = 7)
abline(h=0,col="grey")
dgeObj
# Substituir caracteres especiais nos valores de expr
<<<<<<< HEAD
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
=======
meta_expr = gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta_expr = gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Substituir caracteres especiais nos valores de expr
meta_expr = gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta_expr = gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
View(meta)
# Substituir caracteres especiais nos valores de expr
meta_expr = gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta_expr = gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Substituir caracteres especiais nos valores de expr
#meta_expr =
gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta_expr = gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Substituir caracteres especiais nos valores de expr
#meta_expr =
gsub("prox.-prolif.", "prox_prolif", meta$expr)
#meta_expr =
gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
View(meta)
# Substituir caracteres especiais nos valores de expr
gsub("prox.-prolif.", "prox_prolif", meta$expr)
gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Substituir caracteres especiais nos valores de expr
gsub("prox.-prolif.", "prox_prolif", meta$expr)
gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Substituir caracteres especiais nos valores de expr
gsub("prox.-prolif.", "prox_prolif", meta$expr)
gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
View(meta)
levels(meta$expr)
# Substituir caracteres especiais nos valores de expr
gsub("prox.-prolif.", "prox_prolif", meta$expr)
# Substituir caracteres especiais nos valores de expr
gsub("prox.-prolif.", "prox_prolif", meta$expr)
gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Substituir caracteres especiais nos valores de expr
gsub("prox.-prolif.", "prox_prolif", meta$expr)
gsub("prox.-inflam", "prox_inflam", meta$expr)
>>>>>>> clustering
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Definir a variável de design
<<<<<<< HEAD
design = model.matrix(~meta_expr)
=======
design = model.matrix(~ meta$expr)
head(design)
# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
#meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
#meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Substituir caracteres especiais nos valores de expr
meta_expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta_expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
#meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
levels(meta$expr)
# Substituir caracteres especiais nos valores de expr
gsub("prox.-prolif.", "prox_prolif", meta$expr)
gsub("prox.-inflam", "prox_inflam", meta$expr)
# Definir a variável de design
design = model.matrix(~ meta$expr)
head(design)
levels(meta$expr)
# Definir a variável de design
design = model.matrix(~ meta$expr)
>>>>>>> clustering
head(design)
dgeObj = estimateCommonDisp(dgeObj)
dgeObj$common.dispersion
dgeObj = estimateGLMTrendedDisp(dgeObj)
<<<<<<< HEAD
dgeObj = estimateTagwiseDisp(dgeObj)
plotBCV(dgeObj)
fit = glmFit(dgeObj, design)
head(fit$coefficients)
lrt.BvsL = glmLRT(fit, coef = 2)
topTags(lrt.BvsL)
results_PP <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results_PP
dim(results_PP)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results_PP$FDR)
plot(results_PP$logFC,signif,pch=16)
points(results_PP[detags,"logFC"],-log10(results_PP[detags,"FDR"]),pch=16,col="red")
lrt.BvsL = glmLRT(fit, coef = 3)
topTags(lrt.BvsL)
results_Tru <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results_Tru
dim(results_Tru)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results_Tru$FDR)
plot(results_Tru$logFC,signif,pch=16)
points(results_Tru[detags,"logFC"],-log10(results_Tru[detags,"FDR"]),pch=16,col="red")
# Function: Adjacency matrix to list -------------------------
matrix_to_list <- function(pws){
pws.l <- list()
for (pw in colnames(pws)) {
pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
}
return(pws.l)
}
## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE){
# for debug
#file <- gmt_files[1]
#genes_in_data <- df$gene_symbol
# Read in gmt file
gmt <- gmtPathways(gmt_file)
hidden <- unique(unlist(gmt))
# Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
mat <- matrix(NA, dimnames = list(hidden, names(gmt)),
nrow = length(hidden), ncol = length(gmt))
for (i in 1:dim(mat)[2]){
mat[,i] <- as.numeric(hidden %in% gmt[[i]])
}
#Subset to the genes that are present in our data to avoid bias
hidden1 <- intersect(genes_in_data, hidden)
mat <- mat[hidden1, colnames(mat)[which(colSums(mat[hidden1,])>5)]] # filter for gene sets with more than 5 genes annotated
# And get the list again
final_list <- matrix_to_list(mat) # for this we use the function we previously defined
if(savefile){
saveRDS(final_list, file = paste0(gsub('.gmt', '', gmt_file), '_subset_', format(Sys.time(), '%d%m'), '.RData'))
}
#print('Wohoo! .gmt conversion successfull!:)') # optional
return(final_list)
}
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_TRU$row_names <- rownames(results_TRU)
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_Tru$row_names <- rownames(results_Tru)
# Now, rearrange the columns so that the 'row_names' column comes first
results_PP_mod <- results_PP[, c("row_names", names(results_PP)[-ncol(results_PP)])]
results_Tru_mod <- results_TRU[, c("row_names", names(results_TRU)[-ncol(results_TRU)])]
lrt.BvsL = glmLRT(fit, coef = 3)
topTags(lrt.BvsL)
results_TRU <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results_TRU
dim(results_TRU)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results_TRU$FDR)
plot(results_TRU$logFC,signif,pch=16)
points(results_TRU[detags,"logFC"],-log10(results_TRU[detags,"FDR"]),pch=16,col="red")
# Function: Adjacency matrix to list -------------------------
matrix_to_list <- function(pws){
pws.l <- list()
for (pw in colnames(pws)) {
pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
}
return(pws.l)
}
## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE){
# for debug
#file <- gmt_files[1]
#genes_in_data <- df$gene_symbol
# Read in gmt file
gmt <- gmtPathways(gmt_file)
hidden <- unique(unlist(gmt))
# Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
mat <- matrix(NA, dimnames = list(hidden, names(gmt)),
nrow = length(hidden), ncol = length(gmt))
for (i in 1:dim(mat)[2]){
mat[,i] <- as.numeric(hidden %in% gmt[[i]])
}
#Subset to the genes that are present in our data to avoid bias
hidden1 <- intersect(genes_in_data, hidden)
mat <- mat[hidden1, colnames(mat)[which(colSums(mat[hidden1,])>5)]] # filter for gene sets with more than 5 genes annotated
# And get the list again
final_list <- matrix_to_list(mat) # for this we use the function we previously defined
if(savefile){
saveRDS(final_list, file = paste0(gsub('.gmt', '', gmt_file), '_subset_', format(Sys.time(), '%d%m'), '.RData'))
}
#print('Wohoo! .gmt conversion successfull!:)') # optional
return(final_list)
}
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_TRU$row_names <- rownames(results_TRU)
# Now, rearrange the columns so that the 'row_names' column comes first
results_PP_mod <- results_PP[, c("row_names", names(results_PP)[-ncol(results_PP)])]
results_TRU_mod <- results_TRU[, c("row_names", names(results_TRU)[-ncol(results_TRU)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
results_PP_mod$row_names <- sub("\\..*", "", results_PP_mod$row_names)
results_TRU_mod$row_names <- sub("\\..*", "", results_TRU_mod$row_names)
print(results_PP_mod)
print(results_TRU_mod)
#Variável
my_genes_PP = results_PP_mod$row_names
my_genes_Tru = results_TRU_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id_PP <- grch38 %>%
filter(ensgene %in% results_PP_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_id_TRU <- grch38 %>%
filter(ensgene %in% results_TRU_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id_PP <- grch38 %>%
filter(ensgene %in% results_PP_mod$row_names) %>%
# Select both 'ensgene' and 'symbol' columns
select(ensgene, symbol)
resultados_ensembl_id_TRU <- grch38 %>%
filter(ensgene %in% results_TRU_mod$row_names) %>%
# Select both 'ensgene' and 'symbol' columns
select(ensgene, symbol)
# Print the filtered table
print(resultados_id_PP)
print(resultados_id_TRU)
resultados_id_PP = as.data.frame(resultados_id_PP)
resultados_id_TRU = as.data.frame(resultados_id_TRU)
resultados_ensembl_id_PP
resultados_ensembl_id_TRU
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_TRU$row_names <- rownames(results_TRU)
# Now, rearrange the columns so that the 'row_names' column comes first
results_PP_mod <- results_PP[, c("row_names", names(results_PP)[-ncol(results_PP)])]
results_TRU_mod <- results_TRU[, c("row_names", names(results_TRU)[-ncol(results_TRU)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
results_PP_mod$row_names <- sub("\\..*", "", results_PP_mod$row_names)
results_TRU_mod$row_names <- sub("\\..*", "", results_TRU_mod$row_names)
print(results_PP_mod)
print(results_TRU_mod)
#Variável
my_genes_PP = results_PP_mod$row_names
my_genes_TRU = results_TRU_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id_PP <- grch38 %>%
filter(ensgene %in% results_PP_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_id_TRU <- grch38 %>%
filter(ensgene %in% results_TRU_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id_PP <- grch38 %>%
filter(ensgene %in% results_PP_mod$row_names) %>%
# Select both 'ensgene' and 'symbol' columns
select(ensgene, symbol)
resultados_ensembl_id_TRU <- grch38 %>%
filter(ensgene %in% results_TRU_mod$row_names) %>%
# Select both 'ensgene' and 'symbol' columns
select(ensgene, symbol)
# Print the filtered table
print(resultados_id_PP)
print(resultados_id_TRU)
resultados_id_PP = as.data.frame(resultados_id_PP)
resultados_id_TRU = as.data.frame(resultados_id_TRU)
resultados_ensembl_id_PP
resultados_ensembl_id_TRU
# Substituir os nomes das colunas "row_names" do dataframe "resultados_mod" pelos valores correspondentes da coluna "symbol" do dataframe "resultados_ensembl_id"
results_PP_mod$row_names <- resultados_ensembl_id_PP$symbol[match(gsub("\\..*", "", results_PP_mod$row_names), resultados_ensembl_id_PP$ensgene)]
results_TRU_mod$row_names <- resultados_ensembl_id_TRU$symbol[match(gsub("\\..*", "", results_TRU_mod$row_names), resultados_ensembl_id_TRU$ensgene)]
# Resultado final
print(results_PP_mod)
print(results_TRU_mod)
# Remover os nomes das linhas do dataframe
rownames(results_PP_mod) <- NULL
rownames(results_TRU_mod) <- NULL
# Resultado final
print(results_PP_mod)
print(results_TRU_mod)
# ordenar os resultados por ordem decrescente dos valores da coluna "logFC"
results_PP.ord <- results_PP_mod[ order(-results_PP[,"logFC"]), ]
results_TRU.ord <- results_TRU_mod[ order(-results_TRU[,"logFC"]), ]
# somar um pseudo valor a resultados com valores de "logFC" iguais para permitir um desempate entre "logFC duplicados" e não surgirem problemas ao correr a função fgsea.
epsilon_PP <- runif(sum(duplicated(results_PP.ord$logFC)), min = 0, max = .001)
results_PP.ord$logFC[duplicated(results_PP.ord$logFC)] <- results_PP.ord$logFC[duplicated(results_PP.ord$logFC)] + epsilon_PP
epsilon_TRU <- runif(sum(duplicated(results_TRU.ord$logFC)), min = 0, max = .001)
results_TRU.ord$logFC[duplicated(results_TRU.ord$logFC)] <- results_TRU.ord$logFC[duplicated(results_TRU.ord$logFC)] + epsilon_TRU
# criar uma variável com todos os genes do dataset e os respetivos valores de "logFC"
ranks_PP <- results_PP.ord$logFC
ranks_TRU <- results_TRU.ord$logFC
names(ranks_PP) <- results_PP.ord$row_names
names(ranks_TRU) <- results_TRU.ord$row_names
head(ranks_PP)
head(ranks_TRU)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks_PP)
plot(ranks_TRU)
barplot(ranks_PP)
barplot(ranks_TRU)
vector_PP = unlist(resultados_id_PP)
vector_TRU = unlist(resultados_id_TRU)
# Carregar ficheiro gmt
#bg_genes = prepare_gmt("C:\\Users\\olive\\Desktop\\Extracao\\c2.cp.v2023.2.Hs.symbols.gmt", vector, savefile = FALSE)
bg_genes_PP = prepare_gmt("~/h.all.v2023.2.Hs.symbols.gmt", vector_PP, savefile = FALSE)
bg_genes_TRU = prepare_gmt("~/h.all.v2023.2.Hs.symbols.gmt", vector_TRU, savefile = FALSE)
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking_PP <- max(ranks_PP[is.finite(ranks_PP)])
min_ranking_PP <- min(ranks_PP[is.finite(ranks_PP)])
rankings_PP <- replace(ranks_PP, ranks_PP > max_ranking_PP, max_ranking_PP * 10)
rankings_PP <- replace(ranks_PP, ranks_PP < min_ranking_PP, min_ranking_PP * 10)
rankings_PP <- sort(ranks_PP, decreasing = TRUE) # sort genes by ranking
max_ranking_TRU <- max(ranks_TRU[is.finite(ranks_TRU)])
min_ranking_TRU <- min(ranks_TRU[is.finite(ranks_TRU)])
rankings_TRU <- replace(ranks_TRU, ranks_TRU > max_ranking_TRU, max_ranking_TRU * 10)
rankings_TRU <- replace(ranks_TRU, ranks_TRU < min_ranking_TRU, min_ranking_TRU * 10)
rankings_TRU <- sort(ranks_TRU, decreasing = TRUE) # sort genes by ranking
# rankings of first 50 genes for the "exprprox.-inflam" coefficient
ggplot(data.frame(gene_symbol = names(ranks_PP)[1:50], ranks = ranks_PP[1:50]), aes(gene_symbol, ranks)) +
geom_point() +
theme_classic() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# rankings of first 50 genes for the "exprTRU" coefficient
ggplot(data.frame(gene_symbol = names(ranks_TRU)[1:50], ranks = ranks_TRU[1:50]), aes(gene_symbol, ranks)) +
geom_point() +
theme_classic() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# Run fgsea
fgseaRes_PP <- fgsea(pathways = bg_genes_PP,
stats = rankings_PP,
scoreType = 'std',
minSize=15,
maxSize = 500)
class(fgseaRes_PP)
dim(fgseaRes_PP)
head(fgseaRes_PP[order(padj), ])
sum(fgseaRes_PP[, padj < 0.05]) # number of significant pathways
# plot top pathways for the "exprprox.-inflam" coefficient
topPathwaysUp_PP <- fgseaRes_PP[ES > 0][head(order(padj), n = 25), pathway]
topPathwaysDown_PP <- fgseaRes_PP[ES < 0][head(order(padj), n = 5), pathway]
topPathways_PP <- c(topPathwaysUp_PP, rev(topPathwaysDown_PP))
plotGseaTable(bg_genes_PP[topPathways_PP], stats = rankings_PP, fgseaRes = fgseaRes_PP, gseaParam = 0.5)
# Run fgsea
fgseaRes_TRU <- fgsea(pathways = bg_genes_TRU,
stats = rankings_TRU,
scoreType = 'std',
minSize=15,
maxSize = 500)
class(fgseaRes_TRU)
dim(fgseaRes_TRU)
head(fgseaRes_TRU[order(padj), ])
sum(fgseaRes_TRU[, padj < 0.05]) # number of significant pathways
# plot top pathways for the "exprTRU" coefficient
topPathwaysUp_TRU <- fgseaRes_TRU[ES > 0][head(order(padj), n = 25), pathway]
topPathwaysDown_TRU <- fgseaRes_TRU[ES < 0][head(order(padj), n = 5), pathway]
topPathways_TRU <- c(topPathwaysUp_TRU, rev(topPathwaysDown_TRU))
plotGseaTable(bg_genes_TRU[topPathways_TRU], stats = rankings_TRU, fgseaRes = fgseaRes_TRU, gseaParam = 0.5)
# plot the most significantly enriched pathway for the "exprprox.-inflam" coefficient
plotEnrichment(bg_genes_PP[[head(fgseaRes_PP[order(padj), ], 1)$pathway]],
rankings_PP) +
labs(title = head(fgseaRes_PP[order(padj), ], 1)$pathway)
# plot the most significantly enriched pathway for the "exprTRU" coefficient
plotEnrichment(bg_genes_TRU[[head(fgseaRes_TRU[order(padj), ], 1)$pathway]],
rankings_TRU) +
labs(title = head(fgseaRes_TRU[order(padj), ], 1)$pathway)
setwd("C:/Users/tsamu/Documents/Universidade/Mestrado_Bioinformatica/Ano_1/Semestre_2/Extracao_de_Conhecimento_de_Dados_Biologicos/Trabalho_Pratico/Extracao")
setwd("C:/Users/tsamu/Documents/Universidade/Mestrado_Bioinformatica/Ano_1/Semestre_2/Extracao_de_Conhecimento_de_Dados_Biologicos/Trabalho_Pratico/Extracao")
=======
>>>>>>> clustering
