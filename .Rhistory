# Criação do objeto para a análise de expr. diferencial
dgeObj = DGEList(counts_keep)
names(dgeObj)
head(dgeObj$samples)
## distributions - log transform
logcounts = cpm(dgeObj,log=TRUE)
boxplot(logcounts[,1:50], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,51:100], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,101:150], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,151:200], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,201:248], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 10 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:10]
head(select_var)
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
# Substituir caracteres especiais nos valores de expr
#meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
#meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
group = paste(meta$expr)
group = as.character(group)
group
# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
group = paste(meta$expr)
group = as.character(group)
group
expr = sapply(strsplit(group, ".", fixed=T), function(x) x[2])
expr = factor(expr, levels = c("prox_prolif", "prox_inflam", "TRU"))
# Definir a variável de design
design = model.matrix(~expr)
head(design)
dgeObj = estimateCommonDisp(dgeObj)
View(design)
View(design)
dgeObj$common.dispersion
dgeObj = estimateGLMTrendedDisp(dgeObj)
dgeObj = estimateTagwiseDisp(dgeObj)
plotBCV(dgeObj)
fit = glmFit(dgeObj, design)
# Verificar número de amostras em 'group'
n_samples_group <- length(group)
print(paste("Número de amostras em 'group':", n_samples_group))
# Verificar número de amostras em 'dgeObj'
n_samples_dgeObj <- ncol(dgeObj)
print(paste("Número de amostras em 'dgeObj':", n_samples_dgeObj))
# Verificar se 'expr' foi corretamente criada
print(head(expr))
# Verificar os níveis de 'expr'
print(levels(expr))
# Verificar a matriz de design
print(head(design))
# Verificar as dimensões da matriz de design
print(dim(design))
# Verificar os dados de expressão
print(head(dgeObj))
# Verificar as dimensões dos dados de expressão
print(dim(dgeObj))
# Verificar se há valores ausentes nos dados de expressão
print(sum(is.na(dgeObj)))
#expr = sapply(strsplit(group, ".", fixed=T), function(x) x[2])
#expr = factor(expr, levels = c("prox_prolif", "prox_inflam", "TRU"))
# Definir a variável de design
design = model.matrix(~group)
head(design)
# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
expr = factor(expr, levels = c("prox_prolif", "prox_inflam", "TRU"))
# Definir a variável de design
design = model.matrix(~expr)
head(design)
# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
expr = factor(expr, levels = c("prox_prolif", "prox_inflam", "TRU"))
group = paste(expr)
# Definir a variável de design
design = model.matrix(~group)
# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
group = paste(meta$expr)
group = as.character(group)
group
#expr = sapply(strsplit(group, ".", fixed=T), function(x) x[2])
#expr = factor(expr, levels = c("prox_prolif", "prox_inflam", "TRU"))
# Definir a variável de design
design = model.matrix(~group)
head(design)
# Definir a variável de design
design = model.matrix(~group)
head(design)
dgeObj = estimateCommonDisp(dgeObj)
dgeObj$common.dispersion
dgeObj = estimateGLMTrendedDisp(dgeObj)
dgeObj = estimateTagwiseDisp(dgeObj)
fit = glmFit(dgeObj, design)
head(fit$coefficients)
lrt.BvsL = glmLRT(fit, coef = 2)
topTags(lrt.BvsL)
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results$FDR)
plot(results$logFC,signif,pch=16)
points(results[detags,"logFC"],-log10(results[detags,"FDR"]),pch=16,col="red")
lrt.BvsL = glmLRT(fit, coef = 3)
topTags(lrt.BvsL)
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results$FDR)
plot(results$logFC,signif,pch=16)
points(results[detags,"logFC"],-log10(results[detags,"FDR"]),pch=16,col="red")
## edgeR
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("edgeR")
## limma
#BiocManager::install("limma")
## Glimma
#BiocManager::install(c("Glimma"))
##gplots
#BiocManager::install(c("gplots"))
##org.Mm.eg.db
#BiocManager::install(c("org.Mm.eg.db"))
##RColorBrewer
#BiocManager::install(c("RColorBrewer"))
BiocManager::install(c("biomaRt"))
BiocManager::install(c("GSEABase"))
BiocManager::install(c("fgsea"))
##TCGAbiolinks
#if (!requireNamespace("TCGAbiolinks", quietly = TRUE))
#  BiocManager::install("TCGAbiolinks")
# Tamanho do objeto
dim(luad_data)
# Informação sobre o estudo
metadata(luad_data)
# Informação sobre os tipos de dados de RNASeq
names(assays(luad_data))
# Tipos de metadados associados a cada gene
names(rowData(luad_data))
# Tipos de metadados associados a cada amostra
names(colData(luad_data))
suppressMessages({
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(org.Mm.eg.db)
library(RColorBrewer)
library(TCGAbiolinks)
library(SummarizedExperiment)
library(biomaRt)
library(GSEABase)
library(fgsea)
library(clusterProfiler)
})
## edgeR
#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("edgeR")
## limma
#BiocManager::install("limma")
## Glimma
#BiocManager::install(c("Glimma"))
##gplots
#BiocManager::install(c("gplots"))
##org.Mm.eg.db
#BiocManager::install(c("org.Mm.eg.db"))
##RColorBrewer
#BiocManager::install(c("RColorBrewer"))
##biomaRt
#BiocManager::install(c("biomaRt"))
##GSEABase
#BiocManager::install(c("GSEABase"))
##fgsea
#BiocManager::install(c("fgsea"))
##TCGAbiolinks
#if (!requireNamespace("TCGAbiolinks", quietly = TRUE))
#  BiocManager::install("TCGAbiolinks")
##clusterProfiler
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("clusterProfiler")
suppressMessages({
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(org.Mm.eg.db)
library(RColorBrewer)
library(TCGAbiolinks)
library(SummarizedExperiment)
library(biomaRt)
library(GSEABase)
library(fgsea)
library(clusterProfiler)
})
# Tamanho do objeto
dim(luad_data)
# Informação sobre o estudo
metadata(luad_data)
# Informação sobre os tipos de dados de RNASeq
names(assays(luad_data))
# Tipos de metadados associados a cada gene
names(rowData(luad_data))
# Tipos de metadados associados a cada amostra
names(colData(luad_data))
# Carregamento, extração e transformação dos dados provenientes do RNAseq
seqdata = as.data.frame(assay(luad_data, 'unstranded'))
#Verificação da inexistência de valores NA
any(is.na(seqdata))
# Carregamento de metadados
sample_id = substr(luad_data$sample_id, 1, 10)
expr = luad_data$paper_expression_subtype
meta = data.frame(sample_id = sample_id, expr = expr)
# Limpeza dos dados e tratamento relativo ao género
any(is.na(meta$expr))
meta = meta[!is.na(meta$expr),]
table(meta$expr)
#filter = meta$expr != '[Not Available]'
#meta = meta[filter,]
# Criar uma vista dos dados de RNASeq com base nos subtipos de expressão
seqdata_filter = seqdata[,meta$expr]
View(seqdata_filter)
# Limpeza dos dados e tratamento relativo ao género
any(is.na(meta$expr))
meta = meta[!is.na(meta$expr),]
table(meta$expr)
filter = meta$expr != '[Not Available]'
meta = meta[filter,]
# Criar uma vista dos dados de RNASeq com base nos subtipos de expressão
seqdata_filter = seqdata[,meta$expr]
# Garantir que as dims estão corretas
dim(seqdata_filter)
dim(meta)
# Corrigir nomes e garantir ordem
colnames(seqdata_filter) = meta$sample_id
all(names(seqdata_filter) == meta$sample_id)
# Calculamos CPM
calccpm = cpm(seqdata_filter)
# Aparamos os dados, removendo genes com baixa expressão
# é geralmente aceite a eliminação de genes com CPM inferior a 0.5 em mais do que 2 amostras
thresh = calccpm > 0.5
keep = rowSums(thresh) >= 2
counts_keep = seqdata_filter[keep,]
summary(keep)
dim(counts_keep)
# Criação do objeto para a análise de expr. diferencial
dgeObj = DGEList(counts_keep)
names(dgeObj)
head(dgeObj$samples)
## distributions - log transform
logcounts = cpm(dgeObj,log=TRUE)
# Set up the connection to Ensembl
ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
ensembl_dataset <- useDataset('hsapiens_gene_ensembl', mart = ensembl)
# Remove version numbers from Ensembl gene IDs in logcounts
ensembl_ids <- gsub("\\..*", "", rownames(logcounts))
rownames(logcounts) <- ensembl_ids
# Retrieve gene symbols for the Ensembl IDs
gene_symbols <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
filters = "ensembl_gene_id",
values = ensembl_ids,
mart = ensembl)
View(counts_keep)
# Loop through each Ensembl gene ID in seqdata
for (i in seq_along(ensembl_ids)) {
# Find the index of the Ensembl gene ID in gene_symbols
idx <- match(ensembl_ids[i], gene_symbols$ensembl_gene_id)
# If a corresponding gene symbol is found and it's not an empty string, replace the row name
if (!is.na(idx) && gene_symbols$external_gene_name[idx] != "") {
rownames(logcounts)[i] <- gene_symbols$external_gene_name[idx]
}
}
boxplot(logcounts[,1:50], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,51:100], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,101:150], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,151:200], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,201:248], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
View(logcounts)
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 10 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:10]
head(select_var)
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 10 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:10]
select_var
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
## distributions - log transform
logcounts = cpm(dgeObj,log=TRUE)
# Set up the connection to Ensembl
ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
ensembl_dataset <- useDataset('hsapiens_gene_ensembl', mart = ensembl)
# Remove version numbers from Ensembl gene IDs in logcounts
ensembl_ids <- gsub("\\..*", "", rownames(logcounts))
rownames(logcounts) <- ensembl_ids
# Retrieve gene symbols for the Ensembl IDs
gene_symbols <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
filters = "ensembl_gene_id",
values = ensembl_ids,
mart = ensembl)
# Loop through each Ensembl gene ID in seqdata
for (i in seq_along(ensembl_ids)) {
# Find the index of the Ensembl gene ID in gene_symbols
idx <- match(ensembl_ids[i], gene_symbols$ensembl_gene_id)
# If a corresponding gene symbol is found and it's not an empty string, replace the row name
if (!is.na(idx) && gene_symbols$external_gene_name[idx] != "") {
rownames(logcounts)[i] <- gene_symbols$external_gene_name[idx]
}
}
boxplot(logcounts[,1:50], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,51:100], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,101:150], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,151:200], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,201:248], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 10 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:10]
select_var
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
View(logcounts)
# Verifica se algum título das linhas começa com "ENS"
ens_row_titles <- grep("^ENS", rownames(logcounts))
# Se 'ens_row_titles' não estiver vazio, significa que existem títulos de linhas que começam com "ENS"
if (length(ens_row_titles) > 0) {
cat("Existem", length(ens_row_titles), "títulos de linhas que começam com 'ENS'.\n")
print(rownames(logcounts)[ens_row_titles])
} else {
cat("Não existem títulos de linhas que começam com 'ENS'.\n")
}
## distributions - log transform
logcounts = cpm(dgeObj,log=TRUE)
## Set up the connection to Ensembl
#ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
#ensembl_dataset <- useDataset('hsapiens_gene_ensembl', mart = ensembl)
# Remove version numbers from Ensembl gene IDs in logcounts
#ensembl_ids <- gsub("\\..*", "", rownames(logcounts))
#rownames(logcounts) <- ensembl_ids
# Retrieve gene symbols for the Ensembl IDs
#gene_symbols <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
#                      filters = "ensembl_gene_id",
#                      values = ensembl_ids,
#                      mart = ensembl)
# Loop through each Ensembl gene ID in seqdata
#for (i in seq_along(ensembl_ids)) {
# Find the index of the Ensembl gene ID in gene_symbols
#  idx <- match(ensembl_ids[i], gene_symbols$ensembl_gene_id)
# If a corresponding gene symbol is found and it's not an empty string, replace the row name
#  if (!is.na(idx) && gene_symbols$external_gene_name[idx] != "") {
#    rownames(logcounts)[i] <- gene_symbols$external_gene_name[idx]
#  }
#}
boxplot(logcounts[,1:50], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,51:100], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,101:150], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,151:200], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
boxplot(logcounts[,201:248], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
# Verifica se todas as linhas começam com "ENS"
all_ens <- all(grepl("^ENS", rownames(logcounts)))
# Se 'all_ens' for TRUE, significa que todas as linhas começam com "ENS"
if (all_ens) {
cat("Todas as linhas começam com 'ENS'.\n")
} else {
cat("Algumas linhas não começam com 'ENS'.\n")
}
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 10 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:10]
select_var
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
mypalette <- brewer.pal(9,"RdYlBu")
morecols <- colorRampPalette(mypalette)
col.cell1 = c("purple","orange", "green")[meta$expr]
heatmap.2(highly_variable_lcpm,
col=rev(morecols(50)),
trace="column",
main="Top 10 most variable genes across samples",
ColSideColors=col.cell1,scale="row")
dgeObj = calcNormFactors(dgeObj)
# demo
plotMD(logcounts, column = 7)
abline(h=0,col="grey")
plotMD(dgeObj, column = 7)
abline(h=0,col="grey")
dgeObj
# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
group = paste(meta$expr)
group = as.character(group)
group
# Definir a variável de design
design = model.matrix(~group)
head(design)
dgeObj = estimateCommonDisp(dgeObj)
dgeObj$common.dispersion
dgeObj = estimateGLMTrendedDisp(dgeObj)
dgeObj = estimateTagwiseDisp(dgeObj)
plotBCV(dgeObj)
fit = glmFit(dgeObj, design)
head(fit$coefficients)
lrt.BvsL = glmLRT(fit, coef = 2)
topTags(lrt.BvsL)
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results$FDR)
plot(results$logFC,signif,pch=16)
points(results[detags,"logFC"],-log10(results[detags,"FDR"]),pch=16,col="red")
lrt.BvsL = glmLRT(fit, coef = 3)
topTags(lrt.BvsL)
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results$FDR)
plot(results$logFC,signif,pch=16)
points(results[detags,"logFC"],-log10(results[detags,"FDR"]),pch=16,col="red")
results.ord <- results[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
results.ord <- results[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
pathways <- read.gmt("~/h.all.v2023.2.Hs.entrez.gmt")
pathways <- read.gmt("~/h.all.v2023.2.Hs.entrez.gmt")
pathways <- read.gmt("~/h.all.v2023.2.Hs.entrez.gmt")
