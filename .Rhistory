ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
pathways <- read.gmt("~/h.all.v2023.2.Hs.symbols.gmt")
ensembl_ids <- rownames(results.ord)
mapped_ids <- mapIds(org.Hs.eg.db, keys = ensembl_ids, column = "SYMBOL", keytype = "ENSEMBL")
BiocManager::install(c("org.Hs.eg.db"))
library(org.Hs.eg.db)
results.ord <- results[ order(-results[,"logFC"]), ]
epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon
ranks <- results.ord$logFC
names(ranks) <- rownames(results.ord)
pathways <- read.gmt("~/h.all.v2023.2.Hs.symbols.gmt")
ensembl_ids <- rownames(results.ord)
mapped_ids <- mapIds(org.Hs.eg.db, keys = ensembl_ids, column = "SYMBOL", keytype = "ENSEMBL")
keytypes(org.Hs.eg.db)
ensembl_ids
pathways <- read.gmt("~/h.all.v2023.2.Hs.symbols.gmt")
setwd("C:/Users/tsamu/Documents/Universidade/Mestrado_Bioinformatica/Ano_1/Semestre_2/Extracao_de_Conhecimento_de_Dados_Biologicos/Trabalho_Pratico")
suppressMessages({
library(edgeR)
library(limma)
library(Glimma)
library(gplots)
library(RColorBrewer)
library(TCGAbiolinks)
library(SummarizedExperiment)
library(biomaRt)
library(GSEABase)
library(fgsea)
library(clusterProfiler)
library(ggplot2)
library(dplyr)
library(annotables)
})
load('luad_data_load.rda')
load("~/luad_data_load.rda")
luad_data = data
# Tamanho do objeto
dim(luad_data)
# Informação sobre o estudo
metadata(luad_data)
# Informação sobre os tipos de dados de RNASeq
names(assays(luad_data))
# Tipos de metadados associados a cada gene
names(rowData(luad_data))
# Tipos de metadados associados a cada amostra
names(colData(luad_data))
# Carregamento, extração e transformação dos dados provenientes do RNAseq
seqdata = as.data.frame(assay(luad_data, 'unstranded'))
#Verificação da inexistência de valores NA
any(is.na(seqdata))
# Carregamento de metadados
gender = luad_data$gender
sample_id = substr(luad_data$sample_id, 1, 10)
expr = luad_data$paper_expression_subtype
meta = data.frame(sample_id = sample_id, gender = gender, expr = expr)
##Género
#Verificação da presença de NAs
any(is.na(meta$gender))
# Converte 'gender' para factor com dois níveis
meta$gender = factor(meta$gender, levels = c("male", "female"))
filter = meta$gender != '[Not Available]'
meta = meta[filter,]
#Dimensões da variável
table(meta$gender)
##Subtipos de expressão
#Verificação da presença de NAs
any(is.na(meta$expr))
#Eliminação das colunas correspondentes aos NAs
meta = meta[!is.na(meta$expr),]
filter = meta$expr != '[Not Available]'
meta = meta[filter,]
#Verificação da eliminação dos NAs
any(is.na(meta$expr))
#Dimensões da variável
table(meta$expr)
seqdata_filter = seqdata[,meta$expr]
# Garantir que as dims estão corretas
dim(seqdata_filter)
dim(meta)
# Corrigir nomes e garantir ordem
colnames(seqdata_filter) = meta$sample_id
all(names(seqdata_filter) == meta$sample_id)
genero = table(luad_data$gender)
colors <- c("pink", "lightblue")
max_level <- 400
ylim <- c(0, max_level)
barplot(genero, col = colors, ylim = ylim, main = "Distribuição de Sexo", ylab = "Ocorrências")
legend("topright", legend = names(genero), fill = colors)
for (i in 1:length(genero)) {
text(i, genero[i], labels = genero[i], pos = 3, cex = 0.8, col = "black")
}
#chi_genero = chisq.test(genero)
ages = na.omit(luad_data$paper_Age.at.diagnosis)
ages = ages[ages != '[Not Available]']
ages = as.numeric(as.character(ages))
summary(ages)
# Discretização
breaks = c(40, 50, 60, 70, 80, Inf)
labels = c("40-49", "50-59", "60-69", "70-79", "80 and over")
ages_int = cut(ages, breaks = breaks, labels = labels, include.lowest = TRUE)
# Create bar plot with title and x-axis label
barplot(table(ages_int), main = "Distribuição de idades", xlab = "Intervalos de idades")
abline(h = mean(ages), col = "red", lty = 2, lwd = 1)
legend("topright", legend = paste("Idade média:", round(mean(ages), 2)), col = "red", lty = 2, lwd = 1)
# Combinar as colunas de estado vital e estágio do tumor
vital_stage <- data.frame(vital_status = luad_data$vital_status, tumor_stage = luad_data$paper_Tumor.stage)
# Substituir "Not Available" por NA na variável tumor_stage
vital_stage$tumor_stage <- gsub("Not Available", NA, vital_stage$tumor_stage)
# Remover valores omissos
vital_stage <- vital_stage[complete.cases(vital_stage$tumor_stage), ]
# Criação da tabela de contingência
contingency_table <- table(vital_stage$vital_status, vital_stage$tumor_stage)
# Realização do teste de qui-quadrado
chi_sq_test <- chisq.test(contingency_table)
chi_sq_test
# Representação gráfica
barplot(contingency_table, beside = TRUE, legend.text = TRUE,
main = "Vital Status vs. Tumor Stage",
xlab = "Estágio tumor", ylab = "Frequência",
col = c("lightgreen", "pink"))
# Cálculo CPM
calccpm = cpm(seqdata_filter)
# Remoção de genes com baixa expressão
thresh = calccpm > 0.5
keep = rowSums(thresh) >= 2
counts_keep = seqdata_filter[keep,]
summary(keep)
dim(counts_keep)
# Criação do objeto para a análise de expr. diferencial
dgeObj = DGEList(counts_keep)
names(dgeObj)
head(dgeObj$samples)
## distributions - log transform
logcounts = cpm(dgeObj,log=TRUE)
# Set up the connection to Ensembl
ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
ensembl_dataset <- useDataset('hsapiens_gene_ensembl', mart = ensembl)
# Remove version numbers from Ensembl gene IDs in logcounts
ensembl_ids <- gsub("\\..*", "", rownames(logcounts))
rownames(logcounts) <- ensembl_ids
# Retrieve gene symbols for the Ensembl IDs
gene_symbols <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
filters = "ensembl_gene_id",
values = ensembl_ids,
mart = ensembl)
# Loop through each Ensembl gene ID in seqdata
for (i in seq_along(ensembl_ids)) {
# Find the index of the Ensembl gene ID in gene_symbols
idx <- match(ensembl_ids[i], gene_symbols$ensembl_gene_id)
# If a corresponding gene symbol is found and it's not an empty string, replace the row name
if (!is.na(idx) && gene_symbols$external_gene_name[idx] != "") {
rownames(logcounts)[i] <- gene_symbols$external_gene_name[idx]
}
}
boxplot(logcounts[,1:50], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")
boxplot(logcounts[,51:100], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")
boxplot(logcounts[,101:150], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")
boxplot(logcounts[,151:200], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")
boxplot(logcounts[,201:242], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)
# Seleção dos 10 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:10]
select_var
# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
#head(highly_variable_lcpm)
# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)
# Criação do mapa
mypalette = brewer.pal(9,"RdYlBu")
morecols = colorRampPalette(mypalette)
labels = levels(meta$expr)
col.cell1 = c("purple","orange", "green")[meta$expr]
heatmap.2(highly_variable_lcpm,
col=rev(morecols(50)),
trace="column",
main="Top 10 genes mais variáveis",
ColSideColors=col.cell1,scale="row",
margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta
labels = levels(meta$expr)
col.cell2 = c("purple","orange", "green")[meta$expr][1:50]
heatmap.2(highly_variable_lcpm[,1:50],
col=rev(morecols(50)),
trace="column",
main="Top 10 genes mais variáveis entre 50 amostras aleatórias",
ColSideColors=col.cell2,scale="row",
margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta
dgeObj = calcNormFactors(dgeObj)
# demo
plotMD(logcounts, column = 7)
abline(h=0,col="grey")
plotMD(dgeObj, column = 7)
abline(h=0,col="grey")
dgeObj
# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)
meta_expr = paste(meta$expr)
meta_expr = as.character(meta_expr)
meta_expr
# Definir a variável de design
design = model.matrix(~meta_expr)
head(design)
dgeObj = estimateCommonDisp(dgeObj)
dgeObj$common.dispersion
dgeObj = estimateGLMTrendedDisp(dgeObj)
dgeObj = estimateTagwiseDisp(dgeObj)
plotBCV(dgeObj)
fit = glmFit(dgeObj, design)
head(fit$coefficients)
lrt.BvsL = glmLRT(fit, coef = 2)
topTags(lrt.BvsL)
results_PP <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results_PP
dim(results_PP)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results_PP$FDR)
plot(results_PP$logFC,signif,pch=16)
points(results_PP[detags,"logFC"],-log10(results_PP[detags,"FDR"]),pch=16,col="red")
lrt.BvsL = glmLRT(fit, coef = 3)
topTags(lrt.BvsL)
results_Tru <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results_Tru
dim(results_Tru)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results_Tru$FDR)
plot(results_Tru$logFC,signif,pch=16)
points(results_Tru[detags,"logFC"],-log10(results_Tru[detags,"FDR"]),pch=16,col="red")
# Function: Adjacency matrix to list -------------------------
matrix_to_list <- function(pws){
pws.l <- list()
for (pw in colnames(pws)) {
pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
}
return(pws.l)
}
## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE){
# for debug
#file <- gmt_files[1]
#genes_in_data <- df$gene_symbol
# Read in gmt file
gmt <- gmtPathways(gmt_file)
hidden <- unique(unlist(gmt))
# Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
mat <- matrix(NA, dimnames = list(hidden, names(gmt)),
nrow = length(hidden), ncol = length(gmt))
for (i in 1:dim(mat)[2]){
mat[,i] <- as.numeric(hidden %in% gmt[[i]])
}
#Subset to the genes that are present in our data to avoid bias
hidden1 <- intersect(genes_in_data, hidden)
mat <- mat[hidden1, colnames(mat)[which(colSums(mat[hidden1,])>5)]] # filter for gene sets with more than 5 genes annotated
# And get the list again
final_list <- matrix_to_list(mat) # for this we use the function we previously defined
if(savefile){
saveRDS(final_list, file = paste0(gsub('.gmt', '', gmt_file), '_subset_', format(Sys.time(), '%d%m'), '.RData'))
}
#print('Wohoo! .gmt conversion successfull!:)') # optional
return(final_list)
}
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_TRU$row_names <- rownames(results_TRU)
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_Tru$row_names <- rownames(results_Tru)
# Now, rearrange the columns so that the 'row_names' column comes first
results_PP_mod <- results_PP[, c("row_names", names(results_PP)[-ncol(results_PP)])]
results_Tru_mod <- results_TRU[, c("row_names", names(results_TRU)[-ncol(results_TRU)])]
lrt.BvsL = glmLRT(fit, coef = 3)
topTags(lrt.BvsL)
results_TRU <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results_TRU
dim(results_TRU)
summary(de <- decideTestsDGE(lrt.BvsL))
detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)
signif <- -log10(results_TRU$FDR)
plot(results_TRU$logFC,signif,pch=16)
points(results_TRU[detags,"logFC"],-log10(results_TRU[detags,"FDR"]),pch=16,col="red")
# Function: Adjacency matrix to list -------------------------
matrix_to_list <- function(pws){
pws.l <- list()
for (pw in colnames(pws)) {
pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
}
return(pws.l)
}
## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE){
# for debug
#file <- gmt_files[1]
#genes_in_data <- df$gene_symbol
# Read in gmt file
gmt <- gmtPathways(gmt_file)
hidden <- unique(unlist(gmt))
# Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
mat <- matrix(NA, dimnames = list(hidden, names(gmt)),
nrow = length(hidden), ncol = length(gmt))
for (i in 1:dim(mat)[2]){
mat[,i] <- as.numeric(hidden %in% gmt[[i]])
}
#Subset to the genes that are present in our data to avoid bias
hidden1 <- intersect(genes_in_data, hidden)
mat <- mat[hidden1, colnames(mat)[which(colSums(mat[hidden1,])>5)]] # filter for gene sets with more than 5 genes annotated
# And get the list again
final_list <- matrix_to_list(mat) # for this we use the function we previously defined
if(savefile){
saveRDS(final_list, file = paste0(gsub('.gmt', '', gmt_file), '_subset_', format(Sys.time(), '%d%m'), '.RData'))
}
#print('Wohoo! .gmt conversion successfull!:)') # optional
return(final_list)
}
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_TRU$row_names <- rownames(results_TRU)
# Now, rearrange the columns so that the 'row_names' column comes first
results_PP_mod <- results_PP[, c("row_names", names(results_PP)[-ncol(results_PP)])]
results_TRU_mod <- results_TRU[, c("row_names", names(results_TRU)[-ncol(results_TRU)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
results_PP_mod$row_names <- sub("\\..*", "", results_PP_mod$row_names)
results_TRU_mod$row_names <- sub("\\..*", "", results_TRU_mod$row_names)
print(results_PP_mod)
print(results_TRU_mod)
#Variável
my_genes_PP = results_PP_mod$row_names
my_genes_Tru = results_TRU_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id_PP <- grch38 %>%
filter(ensgene %in% results_PP_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_id_TRU <- grch38 %>%
filter(ensgene %in% results_TRU_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id_PP <- grch38 %>%
filter(ensgene %in% results_PP_mod$row_names) %>%
# Select both 'ensgene' and 'symbol' columns
select(ensgene, symbol)
resultados_ensembl_id_TRU <- grch38 %>%
filter(ensgene %in% results_TRU_mod$row_names) %>%
# Select both 'ensgene' and 'symbol' columns
select(ensgene, symbol)
# Print the filtered table
print(resultados_id_PP)
print(resultados_id_TRU)
resultados_id_PP = as.data.frame(resultados_id_PP)
resultados_id_TRU = as.data.frame(resultados_id_TRU)
resultados_ensembl_id_PP
resultados_ensembl_id_TRU
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_TRU$row_names <- rownames(results_TRU)
# Now, rearrange the columns so that the 'row_names' column comes first
results_PP_mod <- results_PP[, c("row_names", names(results_PP)[-ncol(results_PP)])]
results_TRU_mod <- results_TRU[, c("row_names", names(results_TRU)[-ncol(results_TRU)])]
# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"
# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
results_PP_mod$row_names <- sub("\\..*", "", results_PP_mod$row_names)
results_TRU_mod$row_names <- sub("\\..*", "", results_TRU_mod$row_names)
print(results_PP_mod)
print(results_TRU_mod)
#Variável
my_genes_PP = results_PP_mod$row_names
my_genes_TRU = results_TRU_mod$row_names
# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id_PP <- grch38 %>%
filter(ensgene %in% results_PP_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_id_TRU <- grch38 %>%
filter(ensgene %in% results_TRU_mod$row_names) %>%
# Select only the 'entrez' column
select(symbol)
resultados_ensembl_id_PP <- grch38 %>%
filter(ensgene %in% results_PP_mod$row_names) %>%
# Select both 'ensgene' and 'symbol' columns
select(ensgene, symbol)
resultados_ensembl_id_TRU <- grch38 %>%
filter(ensgene %in% results_TRU_mod$row_names) %>%
# Select both 'ensgene' and 'symbol' columns
select(ensgene, symbol)
# Print the filtered table
print(resultados_id_PP)
print(resultados_id_TRU)
resultados_id_PP = as.data.frame(resultados_id_PP)
resultados_id_TRU = as.data.frame(resultados_id_TRU)
resultados_ensembl_id_PP
resultados_ensembl_id_TRU
# Substituir os nomes das colunas "row_names" do dataframe "resultados_mod" pelos valores correspondentes da coluna "symbol" do dataframe "resultados_ensembl_id"
results_PP_mod$row_names <- resultados_ensembl_id_PP$symbol[match(gsub("\\..*", "", results_PP_mod$row_names), resultados_ensembl_id_PP$ensgene)]
results_TRU_mod$row_names <- resultados_ensembl_id_TRU$symbol[match(gsub("\\..*", "", results_TRU_mod$row_names), resultados_ensembl_id_TRU$ensgene)]
# Resultado final
print(results_PP_mod)
print(results_TRU_mod)
# Remover os nomes das linhas do dataframe
rownames(results_PP_mod) <- NULL
rownames(results_TRU_mod) <- NULL
# Resultado final
print(results_PP_mod)
print(results_TRU_mod)
# ordenar os resultados por ordem decrescente dos valores da coluna "logFC"
results_PP.ord <- results_PP_mod[ order(-results_PP[,"logFC"]), ]
results_TRU.ord <- results_TRU_mod[ order(-results_TRU[,"logFC"]), ]
# somar um pseudo valor a resultados com valores de "logFC" iguais para permitir um desempate entre "logFC duplicados" e não surgirem problemas ao correr a função fgsea.
epsilon_PP <- runif(sum(duplicated(results_PP.ord$logFC)), min = 0, max = .001)
results_PP.ord$logFC[duplicated(results_PP.ord$logFC)] <- results_PP.ord$logFC[duplicated(results_PP.ord$logFC)] + epsilon_PP
epsilon_TRU <- runif(sum(duplicated(results_TRU.ord$logFC)), min = 0, max = .001)
results_TRU.ord$logFC[duplicated(results_TRU.ord$logFC)] <- results_TRU.ord$logFC[duplicated(results_TRU.ord$logFC)] + epsilon_TRU
# criar uma variável com todos os genes do dataset e os respetivos valores de "logFC"
ranks_PP <- results_PP.ord$logFC
ranks_TRU <- results_TRU.ord$logFC
names(ranks_PP) <- results_PP.ord$row_names
names(ranks_TRU) <- results_TRU.ord$row_names
head(ranks_PP)
head(ranks_TRU)
#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks_PP)
plot(ranks_TRU)
barplot(ranks_PP)
barplot(ranks_TRU)
vector_PP = unlist(resultados_id_PP)
vector_TRU = unlist(resultados_id_TRU)
# Carregar ficheiro gmt
#bg_genes = prepare_gmt("C:\\Users\\olive\\Desktop\\Extracao\\c2.cp.v2023.2.Hs.symbols.gmt", vector, savefile = FALSE)
bg_genes_PP = prepare_gmt("~/h.all.v2023.2.Hs.symbols.gmt", vector_PP, savefile = FALSE)
bg_genes_TRU = prepare_gmt("~/h.all.v2023.2.Hs.symbols.gmt", vector_TRU, savefile = FALSE)
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking_PP <- max(ranks_PP[is.finite(ranks_PP)])
min_ranking_PP <- min(ranks_PP[is.finite(ranks_PP)])
rankings_PP <- replace(ranks_PP, ranks_PP > max_ranking_PP, max_ranking_PP * 10)
rankings_PP <- replace(ranks_PP, ranks_PP < min_ranking_PP, min_ranking_PP * 10)
rankings_PP <- sort(ranks_PP, decreasing = TRUE) # sort genes by ranking
max_ranking_TRU <- max(ranks_TRU[is.finite(ranks_TRU)])
min_ranking_TRU <- min(ranks_TRU[is.finite(ranks_TRU)])
rankings_TRU <- replace(ranks_TRU, ranks_TRU > max_ranking_TRU, max_ranking_TRU * 10)
rankings_TRU <- replace(ranks_TRU, ranks_TRU < min_ranking_TRU, min_ranking_TRU * 10)
rankings_TRU <- sort(ranks_TRU, decreasing = TRUE) # sort genes by ranking
# rankings of first 50 genes for the "exprprox.-inflam" coefficient
ggplot(data.frame(gene_symbol = names(ranks_PP)[1:50], ranks = ranks_PP[1:50]), aes(gene_symbol, ranks)) +
geom_point() +
theme_classic() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# rankings of first 50 genes for the "exprTRU" coefficient
ggplot(data.frame(gene_symbol = names(ranks_TRU)[1:50], ranks = ranks_TRU[1:50]), aes(gene_symbol, ranks)) +
geom_point() +
theme_classic() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
# Run fgsea
fgseaRes_PP <- fgsea(pathways = bg_genes_PP,
stats = rankings_PP,
scoreType = 'std',
minSize=15,
maxSize = 500)
class(fgseaRes_PP)
dim(fgseaRes_PP)
head(fgseaRes_PP[order(padj), ])
sum(fgseaRes_PP[, padj < 0.05]) # number of significant pathways
# plot top pathways for the "exprprox.-inflam" coefficient
topPathwaysUp_PP <- fgseaRes_PP[ES > 0][head(order(padj), n = 25), pathway]
topPathwaysDown_PP <- fgseaRes_PP[ES < 0][head(order(padj), n = 5), pathway]
topPathways_PP <- c(topPathwaysUp_PP, rev(topPathwaysDown_PP))
plotGseaTable(bg_genes_PP[topPathways_PP], stats = rankings_PP, fgseaRes = fgseaRes_PP, gseaParam = 0.5)
# Run fgsea
fgseaRes_TRU <- fgsea(pathways = bg_genes_TRU,
stats = rankings_TRU,
scoreType = 'std',
minSize=15,
maxSize = 500)
class(fgseaRes_TRU)
dim(fgseaRes_TRU)
head(fgseaRes_TRU[order(padj), ])
sum(fgseaRes_TRU[, padj < 0.05]) # number of significant pathways
# plot top pathways for the "exprTRU" coefficient
topPathwaysUp_TRU <- fgseaRes_TRU[ES > 0][head(order(padj), n = 25), pathway]
topPathwaysDown_TRU <- fgseaRes_TRU[ES < 0][head(order(padj), n = 5), pathway]
topPathways_TRU <- c(topPathwaysUp_TRU, rev(topPathwaysDown_TRU))
plotGseaTable(bg_genes_TRU[topPathways_TRU], stats = rankings_TRU, fgseaRes = fgseaRes_TRU, gseaParam = 0.5)
# plot the most significantly enriched pathway for the "exprprox.-inflam" coefficient
plotEnrichment(bg_genes_PP[[head(fgseaRes_PP[order(padj), ], 1)$pathway]],
rankings_PP) +
labs(title = head(fgseaRes_PP[order(padj), ], 1)$pathway)
# plot the most significantly enriched pathway for the "exprTRU" coefficient
plotEnrichment(bg_genes_TRU[[head(fgseaRes_TRU[order(padj), ], 1)$pathway]],
rankings_TRU) +
labs(title = head(fgseaRes_TRU[order(padj), ], 1)$pathway)
setwd("C:/Users/tsamu/Documents/Universidade/Mestrado_Bioinformatica/Ano_1/Semestre_2/Extracao_de_Conhecimento_de_Dados_Biologicos/Trabalho_Pratico/Extracao")
setwd("C:/Users/tsamu/Documents/Universidade/Mestrado_Bioinformatica/Ano_1/Semestre_2/Extracao_de_Conhecimento_de_Dados_Biologicos/Trabalho_Pratico/Extracao")
