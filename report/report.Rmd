---
title: "Análise de Expressão Diferencial"
output:
  html_document:
    toc: yes
    toc_depth: 2
    toc_float: yes
    theme: spacelab
    number_sections: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
    
bibliography: referencias.bib
---

```{=html}
<style>
  body {text-align:justify}
</style>
```
# Autoria

O trabalho aqui apresentado foi desenvolvido em conjunto por Mariana Oliveira (PG52648), Rui Sousa (PG21019) e Samuel Baptista (PG49130), realizado no âmbito da Unidade Curricular de Extração de Conhecimento de Dados Biológicos do Mestrado em Bioinformática.

# Abstract

A preencher na fase final do trabalho

# Introdução

O adenocarcinoma é uma forma de cancro maligno que se desenvolve a partir de células glandulares nos tecidos epiteliais e pode originar-se em diversas partes do corpo. Entre os tipos de adenocarcinoma mais comuns, destacam-se os que afetam a mama, pulmão, próstata, trato gastrointestinal, entre outros[@mullangi2023]. Este estudo concentra-se especificamente no adenocarcinoma do pulmão (LUAD), uma das formas de cancro com alta taxa de mortalidade. [@alberg2003]. Para o adenocarcinoma do pulmão foram identificados três tipos de subtipos - *Terminal Respiratory Unit* (TRU), *Proximal Inflamatory* (PI) e *Proximal Proliferative* (PP) - estando estes subtipos associados à expressão diferenciada de diferentes genes associados ao adenocarcinoma [@ho2021cancer].

Ao longo deste estudo foi desenvolvida uma análise de expressão genética diferencial para determinar a ocorrência de diferenças significativas na expressão genética entre pacientes do tipo TRU, PI e PP. Este estudo foi desenvolvido tendo em vista a identifição marcadores genéticos que possam ser úteis para diagnóstico, prognóstico e desenvolvimento de terapias direcionadas para o LUAD. Esperamos que os resultados deste estudo contribuam para uma melhor compreensão da biologia molecular desse tipo de cancro e, consequentemente, para o desenvolvimento de novas estratégias terapêuticas mais eficazes.

# Materiais e métodos

Foi utilizado um dataset público do *The Cancer Genome Atlas Program* (TCGA), disponibilizado através do *NCI Genomic Data Commons* (GDC), com 600 amostras de pacientes com LUAD [@gdc_website].

A análise dos dados foi feita utilizando a ferramenta `edgeR`, uma biblioteca desenvolvida para o Bioconductor [@bioconductor_website] da linguagem de programação R, especialmente projetada para análise de dados de expressão genética baseada em contagens de RNA-seq. A abordagem estatística empregada pelo edgeR é baseada em métodos bayesianos, permitindo uma análise robusta e precisa dos dados de expressão genética[@edgeR_doc].

Ao longo deste relatório serão apresentados os diferentes passos utilizados, desde o processamento dos dados à sua análise, pretendendo-se demonstrar e explicitar programaticamente a *pipeline* utilizada com vista a apresentar um trabalho claro e replicável para outros data sets.

# Tratamento e Análise do dataset

## Pré-processamento

### Requisitos

Para esta análise de expressão diferencial com edgeR utilizamos as seguintes bibliotecas:

-   **edgeR**: uma ferramenta para análise de dados de RNA-seq, oferecendo métodos estatísticos avançados para identificar genes diferencialmente expressos.

-   **limma**: reconhecido por sua flexibilidade e robustez, o limma é amplamente utilizado para análise de microarrays e RNA-seq, oferecendo uma variedade de modelos estatísticos.

-   **Glimma**: essencial para visualização interativa de resultados de análise de expressão diferencial, o Glimma permite explorar e entender melhor os dados por meio de gráficos informativos.

-   **gplots**: um pacote que oferece uma variedade de funções gráficas para visualização de dados, complementando as análises estatísticas.

-   **RColorBrewer**: oferece uma ampla seleção de paletas de cores para visualização de dados, tornando as figuras mais atraentes e informativas.

-   **TCGAbiolinks**: fundamental para acesso e análise de dados do Projeto de Carcinoma Humano (TCGA), permitindo insights valiosos sobre uma variedade de tipos de cancro.

-   **SummarizedExperiment**: oferece uma classe de container eficiente para armazenar dados experimentais de expressão genética ou de sequenciamento, juntamente com metadados relevantes, facilitando a manipulação e análise integrada desses dados.

-   **biomaRt**: interface para o banco de dados biomart, que fornece acesso a uma vasta gama de informações biológicas.

-   **GSEABase**: oferece funcionalidades básicas para realizar análises de enriquecimento genético (GSEA).

-   **fgsea**: implementação eficiente e rápida do algoritmo de GSEA.

-   **clusterProfiler**: oferece ferramentas para realizar análises de GSEA e perfiis de cluster, facilitando a interpretação de conjuntos de genes diferencialmente expressos.

-   **ggplot2**: criação de gráficos em R.

-   **dplyr**: fornece uma série de funções verbais para manipulação de dados.

-   **annotables**: oferece tabelas de anotação para uma variedade de conjuntos de dados, incluindo informações sobre genes.

-   **caret**: wrapper que facilita o processo de aprendizagem automática, simplificando o processo de treino de modelos.

```{r requisitos}

# Lista de requisitos para poder correr o código deste notebook corretamente

suppressMessages({
  if (!require("BiocManager"))
      install.packages("BiocManager")
  
  if (!require("edgeR"))
    BiocManager::install("edgeR")
  
  if (!require("limma"))
    BiocManager::install("limma")
  
  if (!require("Glimma"))
    BiocManager::install(c("Glimma"))
  
  if (!require("gplots"))
    BiocManager::install(c("gplots"))
  
  if (!require("RColorBrewer"))
    BiocManager::install(c("RColorBrewer"))
  
  if (!require("TCGAbiolinks"))
    BiocManager::install("TCGAbiolinks")
  
  if (!require("SummarizedExperiment"))
    BiocManager::install("SummarizedExperiment")
  
  if (!require("biomaRt"))
    BiocManager::install("biomaRt")
  
  if (!require("GSEABase"))
    BiocManager::install(c("GSEABase"))
  
  if (!require("fgsea"))
    BiocManager::install(c("fgsea"))
  
  if (!require("clusterProfiler"))
    BiocManager::install("clusterProfiler")
  
  if (!require("ggplot2"))
    install.packages("ggplot2")
  
  if (!require("dplyr"))
    install.packages("dplyr")
  
  if (!require("annotables")) {
    install.packages("devtools")
    devtools::install_github("stephenturner/annotables")
  }
  
  if (!require("caret"))
    install.packages("caret")

  # carregamento de bibliotecas

  library(edgeR)
  library(limma)
  library(Glimma)
  library(gplots)
  library(RColorBrewer)
  library(TCGAbiolinks)
  library(SummarizedExperiment)
  library(biomaRt)
  library(GSEABase)
  library(fgsea)
  library(clusterProfiler)
  library(ggplot2)
  library(dplyr)
  library(annotables)
  library(caret)
})
```

## Transferência, carregamento e preparação dos datasets necessários

Para a transferência do dataset do conjunto de dados de expressão genética, utilizou-se o pacote TCGAbiolinks, que é uma ferramenta que permite aceder e descarregar dados do TCGA. Na query, definimos a procura específica dos dados do projeto TCGA-LUAD, a categoria dos mesmos é do tipo "Perfil do Transcriptoma" e a estratégia experimental utilizada para gerar esses dados é a RNA-Seq. Os dados foram processados utilizando o algoritmo STAR para alinhamento de sequências, resultando em contagens de leitura para cada gene. Portanto, o parâmetro "workflow.type" foi especificado como "STAR - Counts". Por fim, especificamos que queremos ter acesso aos dados que estão disponíveis publicamente através do parâmetro "access".

Após a transferência dos dados é então gerado um objeto `summarizedExperiment` através do código GDCprepare. Utilizam-se parâmetros para gravar os dados para simplificar o carregamento do objeto posteriormente, caso seja necessário.

```{r transferencia-carregamento-dados}

# Elaboração da query para conectar ao servidor GDC

#luad = GDCquery( 
#  project = "TCGA-LUAD",
#  data.category = "Transcriptome Profiling",
#  experimental.strategy = 'RNA-Seq',
#  workflow.type = "STAR - Counts",
#  access = "open"
#)


# Transferência dos ficheiros

#GDCdownload(luad)


#' Carregamento dos ficheiros num objeto SummarizedExperiment
#' 
#' O parâmetro save permite guardar o histórico num ficheiro compacto
#' tornando a leitura e carregamento numa próxima utilização mais ágil/rápida

#luad_data = GDCprepare(luad,
#                       save = TRUE,
#                       save.filename = 'luad_data_load.rda',
#                       summarizedExperiment = TRUE)

#' No próximo carregamento utilizar apenas o seguinte comando para não saturar o servidor e tornar o processo mais rápido
#' O ficheiro encontra-se aqui: https://ruisousa.me/luad_dataset/luad_data_load.rda

# Alteramos o working  directory para a raiz, para ser mais fácil utilizar as diferentes pastas (modelos, scripts, etc.)
setwd('../')

# Carregamento do ficheiro
load('luad_data_load.rda')
luad_data = data
```

### Exploração inicial do dataset

Abaixo procedemos a uma pequena exploração do dataset anteriormente carregado.

```{r exploracao-dataset}
# Tamanho do objeto
dim(luad_data)

# Informação sobre o estudo
metadata(luad_data)

# Informação sobre os tipos de dados de RNASeq
names(assays(luad_data))

# Tipos de metadados associados a cada gene
names(rowData(luad_data))

# Tipos de metadados associados a cada amostra
names(colData(luad_data))

```

Através da informação fornecida em cima, conseguimos saber que:

-   **dim** - O objeto tem 60660 linhas, cada uma representa um gene, e 600 colunas, que representam as amostras individuais, correspondendo ao especificado na [documentação do estudo](https://portal.gdc.cancer.gov/projects/TCGA-LUAD).

-   **metadata** - Os metadados indicam a data de lançamento dos dados.

-   **assays** - A informação obtida através dos assays dá-nos 6 tipos de dados tendo em consideração a orientação dos transcritos obtidos e diferentes tipos de normalização.

-   **rownames** - Cada linha está rotulada com o ID de um gene no formato Ensembl.

-   **rowData names** - Existem 10 metadados associados a cada gene, incluindo, por exemplo, a "source", o "type" e o "score".

-   **colnames** - As colunas estão rotuladas com os códigos de barras (barcodes) das amostras, identificando cada amostra de forma única.

-   **colData names** - Há 89 metadados associados a cada amostra, que incluem, por exemplo, o estágio do tumor ("paper_Tumor.stage") e o género ("gender").

### Preparação do dataset

Para chegar à estrutura desejável dos dados, realizou-se a transformação do dataset em dataframe a partir dos dados em bruto. Optou-se por extrair os dados de RNAseq correspondentes às contagens `unstranded` uma vez que a direção dos transcritos não é relevante para este trabalho.

Foi também verificada a presença de valores *Not available* (NA).

```{r preparacao dataset}

# Carregamento, extração e transformação dos dados provenientes do RNAseq 
seqdata = as.data.frame(assay(luad_data, 'unstranded'))

#Verificação da inexistência de valores NA
any(is.na(seqdata))

```

### Preparação do dataset com os metadados

De seguida, foram carregados os metadados de interesse, isolando os dados correspondentes ao subtipo de expressão genética e os dados associados à variável "gender" na variável "meta".

```{r criacao-meta}

# Carregamento de metadados

gender = luad_data$gender

sample_id = substr(luad_data$sample_id, 1, 10)

expr = luad_data$paper_expression_subtype

meta = data.frame(sample_id = sample_id, gender = gender, expr = expr)

```

Foi realizado o pré-processamento dos metadados. Inicialmente, foi verificada a presença de valores ausentes em ambas as variáveis do dataset garantindo que os metadados estão prontos para serem utilizados, sem valores ausentes ou inconsistentes.

```{r pre-processamento-meta}

  ##Género

#Verificação da presença de NAs

any(is.na(meta$gender))

# Converte 'gender' para factor com dois níveis
meta$gender = factor(meta$gender, levels = c("male", "female"))

filter = meta$gender != '[Not Available]'

meta = meta[filter,]

#Dimensões da variável

table(meta$gender)


  ##Subtipos de expressão

#Verificação da presença de NAs

any(is.na(meta$expr))

#Eliminação das colunas correspondentes aos NAs

meta = meta[!is.na(meta$expr),]

filter = meta$expr != '[Not Available]'

meta = meta[filter,]

#Verificação da eliminação dos NAs

any(is.na(meta$expr))


#Dimensões da variável

table(meta$expr)

```

### Preparação do dataset (continuação)

Após, foi feita uma filtragem das colunas do dataframe `seqdata` para manter apenas as amostras que possuem informação sobre o subtipo de expressão com base nos metadados previamente tratados.

O resultado é armazenado na variável `seqdata_filter`, que conterá apenas as colunas de `seqdata` associadas a amostras com informação sobre o subtipo de expressão. Esta variável servirá para, posteriormente, criar o objeto de análise de expressão genética

```{r criacao-seqdata_filter}

seqdata_filter = seqdata[,meta$expr]
```

Fazemos uma verificação final para garantir que os dados estão corretamente carregados e é feita a sua correspondência para garantir o correto encadeamento dos dados de expressão com as respetivas amostras.

```{r verficacao-final-dados}

# Garantir que as dims estão corretas

dim(seqdata_filter)

dim(meta)

# Corrigir nomes e garantir ordem 

colnames(seqdata_filter) = meta$sample_id

all(names(seqdata_filter) == meta$sample_id)

```

Como conseguimos observar, o número de colunas do dataframe "seqdata_filter" é igual ao número de linhas do dataframe "meta". Logo, podemos confirmar o correto processamento dos dados de expressão.

## Análise descritiva do dataset

Para iniciar a análise dos dados, realizamos uma série de análises estatísticas descritivas, visando estabelecer correlações preliminares. Primeiramente, examinamos a taxa de incidência do adenocarcinoma do pulmão entre os géneros, de forma a compreender se há disparidades na distribuição das amostras do dataset entre homens e mulheres. Além disso, investigamos a distribuição da taxa de incidência por faixas etárias, procurando identificar possíveis padrões de prevalência relacionados à idade.

Outro aspecto analisado foi a existência de correlação entre a taxa de mortalidade e o estágio do tumor. Esta análise é crucial para entender se há uma relação entre a gravidade da doença e o risco de mortalidade, o que pode fornecer insights importantes para o prognóstico e tratamento.

```{r frequencia-genero}

genero = table(luad_data$gender)

colors <- c("pink", "lightblue")  

max_level <- 400

ylim <- c(0, max_level)

barplot(genero, col = colors, ylim = ylim, main = "Distribuição de Sexo", ylab = "Ocorrências")

legend("topright", legend = names(genero), fill = colors)

for (i in 1:length(genero)) {
  text(i, genero[i], labels = genero[i], pos = 3, cex = 0.8, col = "black")
}

#chi_genero = chisq.test(genero)
```

Analisando os resultados do gráfico de barras, é possível concluir que há uma ampla distribuição de pacientes de ambos os sexos e que há mais amostras de mulheres comparativamente às amostras existentes de homens.

Abaixo é feita uma análise da frequência de idades do *data set*.

```{r frequencia-idade}
ages = na.omit(luad_data$paper_Age.at.diagnosis)
ages = ages[ages != '[Not Available]']
ages = as.numeric(as.character(ages))

summary(ages)

# Discretização
breaks = c(40, 50, 60, 70, 80, Inf)
labels = c("40-49", "50-59", "60-69", "70-79", "80 and over")
ages_int = cut(ages, breaks = breaks, labels = labels, include.lowest = TRUE)

# Create bar plot with title and x-axis label
barplot(table(ages_int), main = "Distribuição de idades", xlab = "Intervalos de idades")
abline(h = mean(ages), col = "red", lty = 2, lwd = 1)
legend("topright", legend = paste("Idade média:", round(mean(ages), 2)), col = "red", lty = 2, lwd = 1)
```

Concluímos que a idade média da população do estudo é aproximadamente 66 anos e que é plausível inferir que o maior volume de incidência está entre os 59 e os 72 anos de idade.

Abaixo analisamos ainda a correlação entre o estágio do tumor e a taxa de mortalidade recorrendo a testes de qui-quadrado.

```{r correlacao-tumor-mortalidade}

# Combinar as colunas de estado vital e estágio do tumor
vital_stage <- data.frame(vital_status = luad_data$vital_status, tumor_stage = luad_data$paper_Tumor.stage)

# Substituir "Not Available" por NA na variável tumor_stage
vital_stage$tumor_stage <- gsub("Not Available", NA, vital_stage$tumor_stage)

# Remover valores omissos
vital_stage <- vital_stage[complete.cases(vital_stage$tumor_stage), ]

# Criação da tabela de contingência
contingency_table <- table(vital_stage$vital_status, vital_stage$tumor_stage)

# Realização do teste de qui-quadrado
chi_sq_test <- chisq.test(contingency_table)
chi_sq_test

# Representação gráfica
barplot(contingency_table, beside = TRUE, legend.text = TRUE,
        main = "Vital Status vs. Tumor Stage",
        xlab = "Estágio tumor", ylab = "Frequência",
        col = c("lightgreen", "pink"))
```

Ao analisar os resultados do teste de qui-quadrado é plausível aferir que, em função do valor de prova (0.008561) é plausível rejeitar a hipótese nula e inferir que existe uma correlação entre o estágio do tumor e a taxa de mortalidade. Uma análise do gráfico de barras em que é comparada a taxa de mortalidade por estágio de tumor permite também tirar esta conclusão, nomeadamente que a partir do estágio IIB a taxa de mortalidade é superior.

# Preparação para análise de expressão diferencial

### Normalização dos dados usando contagens por milhão (CPM)

Neste processo, os dados de expressão genética são refinados antes da análise. Primeiro, é efetuado o cálculo das Contagens Por Milhão (CPM), um método de normalização de níveis de expressão comummente utilizado para análise de dados RNAseq. Este método ajusta diferenças de profundidade da sequenciação, dando dados de expressão relativos mais facilmente comparáveis entre todos os genes da amostra. [@scheepbouwer2023 , @pluto_website] comummente utilizada importante na normalização de dados de sequenciamento.

De seguida, os dados são ajustados para remover genes com expressão muito baixa, uma prática comum na análise de RNAseq. Este critério de remoção, definido como genes com CPM inferior a 0.5 em pelo menos duas amostras, é aplicado para manter apenas os genes mais relevantes.

```{r normalizacao}

# Cálculo CPM
calccpm = cpm(seqdata_filter)

# Remoção de genes com baixa expressão

thresh = calccpm > 0.5
keep = rowSums(thresh) >= 2
counts_keep = seqdata_filter[keep,]

summary(keep)

dim(counts_keep)

```

A analisar o sumário da variável `keep`, que corresponde aos genes que serão mantidos para análise, identificamos que serão desconsiderados **41 131** genes.

Posteriormente, os dados são organizados num objeto `dgeObj`, adequado para análise estatística de expressão diferencial, preparando-os para investigações mais aprofundadas sobre as variações na expressão genética entre as condições estudadas.

### Criação do objeto `dgeObj`

```{r criacao objeto dgeObj}

# Criação do objeto para a análise de expr. diferencial

dgeObj = DGEList(counts_keep)

names(dgeObj)

head(dgeObj$samples)

```

### Logaritmização dos dados

De seguida, procedeu-se à logaritmização dos dados, uma prática comum no tratamento de dados de expressão genético para posterior análise da sua diferenciação. A logaritmização é essencial para reduzir o enviesamento dos dados.

```{r logaritmizacao}

## distributions - log transform
logcounts = cpm(dgeObj,log=TRUE)

# Set up the connection to Ensembl
ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
ensembl_dataset <- useDataset('hsapiens_gene_ensembl', mart = ensembl)

# Remove version numbers from Ensembl gene IDs in logcounts
ensembl_ids <- gsub("\\..*", "", rownames(logcounts))
rownames(logcounts) <- ensembl_ids

# Retrieve gene symbols for the Ensembl IDs
gene_symbols <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
                      filters = "ensembl_gene_id",
                      values = ensembl_ids,
                      mart = ensembl)

# Loop through each Ensembl gene ID in seqdata
for (i in seq_along(ensembl_ids)) {
  # Find the index of the Ensembl gene ID in gene_symbols
  idx <- match(ensembl_ids[i], gene_symbols$ensembl_gene_id)
  # If a corresponding gene symbol is found and it's not an empty string, replace the row name
  if (!is.na(idx) && gene_symbols$external_gene_name[idx] != "") {
    rownames(logcounts)[i] <- gene_symbols$external_gene_name[idx]
  }
}

```

## Análise Exploratória

### Análise por boxplot

O primeiro passo na análise exploratória passa pela geração de boxplots a partir dos dados logaritmizados, com o intuito de investigar a presença de valores atípicos (outliers). A visualização dos dados por meio de boxplots permite uma avaliação rápida e eficiente da dispersão dos dados em relação à sua mediana e quartis, possibilitando a detecção de quaisquer observações que se desviem significativamente do padrão geral, o que pode indicar erros experimentais ou características biológicas distintas.

Considerando a extensão da amostra e a complexidade dos dados, foram criados subconjuntos por amostra para facilitar a análise. Essa abordagem visa segmentar os dados em conjuntos menores e mais fáceis de gerir, o que permite uma análise mais detalhada de cada subgrupo sem sobrecarregar os recursos computacionais ou comprometer a interpretação dos resultados.

```{r boxplots}
boxplot(logcounts[,1:50], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")

boxplot(logcounts[,51:100], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")


boxplot(logcounts[,101:150], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")


boxplot(logcounts[,151:200], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")

boxplot(logcounts[,201:242], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots de logCPMs")
```

Ao analisar os boxplots das contagens logaritmizadas, podemos identificar a presença de outliers que nos pode indicar a existência de genes sobreexpressos ou subexpressos. Esses outliers representam observações que estão significativamente distantes da maioria dos valores no conjunto de dados. No contexto da expressão genética, os outliers podem surgir devido a vários fatores, como erros experimentais, variações biológicas extremas ou mesmo artefatos técnicos durante a geração dos dados. Genes sobreexpressos, em particular, podem ser de interesse em estudos de expressão diferencial, uma vez que podem desempenhar papéis importantes em processos biológicos específicos ou estar associados a doenças.

Portanto, a identificação e o entendimento dos outliers são cruciais para interpretar corretamente os resultados das análises de expressão genétca e para discernir padrões biologicamente relevantes das variações aleatórias nos dados.

### Comparação de níveis de expressão para os diferentes subtipos de LUAD

Abaixo é feita a análise dos padrões de expressão genética associados a diferentes subtipos de LUAD (TRU, PI e PP) dos 10 genes com maior variabilidade detetada com recurso a um *heatmap*. A utilização de *heatmaps* é particularmente útil para análises de expressão genética uma vez que permite a identificação de padrões de expressão genética associados a condições específicas que podem dar pistas no sentido de identificação sobre biomarcadores para cada condição.

Abaixo é apresentado um *heatmap* para os 30 genes com maior variabilidade em termos de níveis de expressão para cada um dos subtipos de LUAD (TRU, PI e PP).

Para facilitar a interpretação dos dados e apoiar a análise do heatmap para todas as amostras, foi gerado um heatmap com um subgrupo contendo menos amostras. Essa abordagem permitiu uma visualização mais clara e detalhada dos padrões de expressão genética presentes em cada subtipo de LUAD.

```{r}
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes = apply(logcounts, 1, var)

# Seleção dos 10 genes com maior variabilidade
select_var = names(sort(var_genes, decreasing=TRUE))[1:100]
select_var

# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm = logcounts[select_var,]
#head(highly_variable_lcpm)

# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'
dim(highly_variable_lcpm)

# Criação do mapa
mypalette = brewer.pal(9,"RdYlBu")
morecols = colorRampPalette(mypalette)

labels = levels(meta$expr)
col.cell1 = c("purple","orange", "green")[meta$expr]
heatmap.2(highly_variable_lcpm, 
          col=rev(morecols(50)),
          trace="column", 
          main="Top 10 genes mais variáveis",
          ColSideColors=col.cell1,scale="row",
          margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta

labels = levels(meta$expr)
col.cell2 = c("purple","orange", "green")[meta$expr][1:50]
heatmap.2(highly_variable_lcpm[,1:50], 
          col=rev(morecols(50)),
          trace="column", 
          main="Top 10 genes mais variáveis entre 50 amostras aleatórias",
          ColSideColors=col.cell2,scale="row",
          margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta
```

Ao analisar os heatmaps, torna-se evidente a presença de diferentes perfis de expressão genética para cada um dos subtipos de LUAD. Em primeiro lugar efetuou-se uma pesquisa sobre a correspondência dos *gene ID*s através dos respetivos *Ensembl ID*s.

-   ENSG00000151632 → AKR1C2

-   ENSG00000248144 → ADH1C

-   ENSG00000225972 → MTND1P

-   ENSG00000286042 → LCAL1

-   ENSG00000186529 → CYP4F3

-   ENSG00000170689 → HOXB9

-   ENSG00000169297 → NR0B1

-   ENSG00000198074 → AKR1B10

-   ENSG00000125255 → SLC10A2

-   ENSG00000266976 → AC079466

Conseguiu-se concluir que os genes MTND1P, LCAL1, da família AKR1, HOXB9, NR0B1, CYP4F3 e ADH1C são sobrexpressos no subtipo TRU. Além disso, observa-se que no subtipo PP destacam-se a sobrexpressão dos genes SLC10A2 e AC079466 (ENSG00000266976), com níveis de expressão dentro da média para os outros subtipos. No entanto, também é visível uma ligeira sobrexpressão do gene ADH1C e a subexpressão do gene AKR1C2. No subtipo PI, destaca-se a subexpressão do gene ADH1C e uma ligeira sobrexpressão dos genes AKR1C2, SLC10A2 e AC079466

Esses resultados sugerem que os genes da família AKR1 (Aldo Ceto Reductases), estão de acordo com a literatura pois, aparecem tipicamente associados à proliferação [@xiao2021]. Atendendo aos resultados é plausível considerá-los como biomarcadores dos subtipos de LUAD e ainda indicadores para a diferenciação entre os subtipos.

Adicionalmente, os genes SLC10A2 e AC079466 também mostram potencial como biomarcadores dos tipos de tumor proximal, com diferenças notáveis entre os subtipos PI e PP.

O gene SLC10A2, é um responsável pela codificação de transportadores de solutos, tendo sido identificado como gene de interesse para a inibição da proliferação de cancro e promoção da aptose sob terapia com bexaroteno [@ai2018]. Uma próxima análise que seria relevante para tirar conclusões acerca destes resultados seria a análise do tipo de terapia a que os pacientes da amostra foram submetidos.

O gene AC079466, em conjunto com genes da família LINC0 (que também são identificados como genes com grande variabilidade de expressão, ainda que estejam no top 50), aparentam desempenhar um papel importante na regulação do complexo DISC1, indiciado como potencial contribuinte para o desenvolvimento de tumores e respostas imunitárias [@zheng2023].

Seria ainda relevante fazer uma análise mais aprofundada sobre este gene, incluindo analisando os níveis de (sub/sobre)expressão dos genes RNF152 e IRAK1, tendo sido documentado o seu papel na regulação da expressão do gene AKR1B10 possivelmente revertendo o fenótipo do tumor e sua malignidade [@zhu2023].

### Normalização por Trimmed Means of M-values (TMM)

A normalização dos dados de RNAseq desempenha um papel crucial no processo de análise realizado pelo edgeR. Por meio do método de Trimmed Means of M-values (TMM), as contagens de leitura são ajustadas levando em consideração a composição global das amostras, o que corrige variações introduzidas durante o sequenciamento. Ao aplicar a função `calcNormFactors()`, o edgeR calcula os fatores de normalização (escala) com base na técnica TMM, assegurando uma correção adequada das diferenças observadas entre as amostras.

O código fornecido ilustra a aplicação desse processo ao objeto de dados `dgeObj`. Em seguida, são gerados gráficos de diferença de média versus média (MD) para visualizar o efeito da normalização nos dados. Esses gráficos permitem avaliar se as variações biológicas são mantidas após o ajuste das contagens, destacando a ausência de diferenças médias entre as amostras como referência para a eficácia da normalização.

Quando as diferenças observadas nos gráficos de MD antes e depois da normalização por TMM são mínimas, isso sugere que o impacto da normalização nas contagens de leitura é insignificante. Isso pode indicar que as variações técnicas introduzidas durante o sequenciamento já eram baixas ou que as amostras possuíam uma composição homogênea.

Embora isso sugira estabilidade nos dados, é importante ressaltar que pequenas diferenças podem ter relevância biológica. Portanto, é necessário interpretar os resultados com cautela, considerando outros aspectos do experimento, como o contexto biológico e as condições experimentais, para compreender plenamente o significado das variações observadas.

```{r}
dgeObj = calcNormFactors(dgeObj)

# demo

plotMD(logcounts, column = 7)
abline(h=0,col="grey")

plotMD(dgeObj, column = 7)
abline(h=0,col="grey")
```

```{r}
dgeObj
```

# Análise de expressão diferencial e de enriquecimento

Na condução da análise de expressão diferencial, selecionou-se a variável correspondente aos subtipos de expressão. Através da agregação de amostras com base nessas características, procuramos comparar os níveis de expressão genética entre os três subtipos - TRU, PI, PP- permitindo identificar genes cujas expressões estão correlacionadas com essas nuances biológicas.

## Agrupamento de variáveis

Em primeiro lugar, colocaram-se os dados referentes aos subtipos de expressão numa variável e, de seguida, coverteu-se a variável "meta_expr" para o tipo "caractér" para permitir futura compatibilidade com as operação efetuadas.

```{r}

# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)

meta_expr = paste(meta$expr)

meta_expr = as.character(meta_expr)

meta_expr

```

## Criação da matriz de design

A matriz de design desempenha um papel fundamental na especificação do desenho experimental e na identificação das variáveis de interesse na análise de expressão diferencial.

Foi feito o delineamento do processo de definição da variável de design.

```{r}

# Definir a variável de design

design = model.matrix(~meta_expr)


head(design)

```

Podemos observar que foi excluído o nível "prox_inflam". A exclusão deste nível da variável na matriz de design ocorreu porque o R utiliza o esquema de codificação dummy para representar variáveis categóricas [@GfG_2023]. É criada uma coluna para cada nível da variável categórica, exceto um, que serve como referência.

No caso de variáveis categóricas uma coluna é criada para cada nível único, exceto um, que é excluído para evitar redundância de informações. Portanto, o R exclui automaticamente um nível para evitar a redundância de informações na matriz de design.

## Ajuste do modelo

Um dos passos mais importantes na análise de dados de expressão genética diferencial usando um modelo Binomial Negativo, como é o caso do edgeR, é a medição do grau de variação de cada gene. Ajustar o modelo, usando o pacote edgeR, envolve três passos. Em primeiro lugar, estima-se a variação comum, "estimateCommonDisp", que nos dá uma ideia da dispersão geral do genoma para o conjunto de dados selecionado [@stanfordSequenceAnalysis].

```{r}
dgeObj = estimateCommonDisp(dgeObj)

dgeObj$common.dispersion

```

O valor de 0.4372775 para a dispersão comum sugere que há uma quantidade moderada de variabilidade nos dados entre os subtipos de adenocarcinoma do pulmão. Logo, os níveis de expressão genética podem variar significativamente em relação à média.

Depois, é necessário ajustar um modelo de tendência que consiste na dispersão média entre todos os genes com abundância semelhante. Ou seja, é o valor ajustado da tendência da dispersão média.

```{r}
dgeObj = estimateGLMTrendedDisp(dgeObj)

```

Por último, foi calculada a dispersão "Tagwise". Este tipo de dispersão é uma medida estatística que quantifica a variabilidade dos dados de expressão genética em relação à média em cada grupo de condições experimentais.

```{r}
dgeObj = estimateTagwiseDisp(dgeObj)

```

Podemos observar a representação gráfica do coeficiente de variação biológica (BCV) do gene em função da abundância do gene (em log2 contagens por milhão).

```{r}
plotBCV(dgeObj)
```

No eixo x, a média log CPM representa a abundância média dos genes nos diferentes grupos ou condições, sendo que valores mais altos indicam maior expressão média dos genes. No eixo y, o BCV mede a variabilidade biológica dos dados de expressão genética, com valores mais altos indicando maior variabilidade entre os genes.

Os pontos pretos no gráfico representam dados individuais de cada gene, enquanto duas linhas são colocadas: uma linha vermelha (*Common*) que permanece relativamente plana, e uma linha azul (*Trend*) que segue um padrão semelhante à linha vermelha.

Podemos verificar o que parecem ser padrões de genes (a preto) e que poderão indicar diferentes comportamentos de grupos de genes em relação à abundância média.

De seguida, foi feito o ajuste do modelo, que segue uma distribuição negativa binomial, às contagens de leituras para cada gene. Para tal, foi utilizada a função **glmFit** que realiza um ajuste aos dados de expressão genética estimando os coeficientes do modelo para cada gene com base nos dados de expressão e na matriz de design especificada.

```{r}

fit = glmFit(dgeObj, design)

head(fit$coefficients)

```

Devolveu um objeto DGEGLM com os valores estimados dos coeficientes GLM para cada gene.

Cada coeficiente representa a mudança esperada na expressão para um aumento unitário na respectiva variável independente, mantendo todas as outras variáveis constantes. Por exemplo:

-   Um aumento unitário em "meta_exprprox_prolif" (subtipo PP) está associado a uma diminuição de 0.09420212 unidades na expressão genética do gene ENSG00000000003.15 (TSPAN6). Estes dados estão de acordo com a literatura uma vez que, a baixa expressão de TSPAN6 correlaciona-se com um mau prognóstico em pacientes com cancro do pulmão [@humbert2022tspan6].

-   Um aumento unitário em "meta_exprTRU" (subtipo TRU) está associado a um aumento de 0.4591496 unidades na expressão do gene ENSG00000000419.1 (DPM1). Este faz parte da via de glicosilação do distroglicano e foram encontradas relação entre a sua sobreexpressão e o desenvolvimento de cancro [@li2020dpm1].

## Teste de Razão de Verossimilhança (LRT)

Seguidamente, foi realizado um teste de razão de verossimilhança (LRT) onde se compararam dois modelos: um incluindo um coeficiente específico para o subtipo PP do adenocarcinoma do pulmão e outro sem esse coeficiente.

-   A hipótese nula é de que o coeficiente não é significativo.

### Para o subtipo PP

A função 'glmLRT' é aplicada ao modelo 'fit' para calcular a estatística do teste, enquanto a função 'topTags' é usada para extrair os principais resultados do LRT, incluindo valores de p, p-ajustados e tamanhos de efeito para o coeficiente testado.

```{r}

lrt.BvsL = glmLRT(fit, coef = 2) 

topTags(lrt.BvsL)

```

-   Resultados e visualização destes

```{r}
results_PP <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results_PP
dim(results_PP)
summary(de <- decideTestsDGE(lrt.BvsL))
```

Cada linha representa um gene específico e inclui informações como a magnitude da mudança na expressão entre os subtipos, indicada pelo Log Fold Change (logFC), e a significância estatística dessa associação, representada pelo valor de P.

Ao analisar os resultados, observamos que alguns genes têm uma expressão significativamente aumentada no subtipo PP, enquanto outros apresentam uma expressão significativamente reduzida. Esses genes podem desempenhar papéis importantes na progressão ou patogênese específica do subtipo PP do adenocarcinoma do pulmão.

Por exemplo, o gene ENSG00000288638.1 (LNCDAT) mostra uma diminuição significativa na expressão no subtipo PP, com um valor de P extremamente baixo, indicando uma forte associação estatística. Por outro lado, o gene ENSG00000232878 (TNF) exibe um aumento significativo na expressão no subtipo PP, também com um valor de P muito baixo. Este último encontra-se associado à forte proliferação de tumores [@wu2010tnf].

De seguida, criou-se um gráfico de dispersão dos valores de log fold-change em relação à média de contagens para cada gene, destacando os genes diferencialmente expressos identificados.

```{r}

detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)

```

Foi ainda criado um volcano plot onde os genes diferencialmente expressos identificados pelo teste são destacados em vermelho.

```{r}

signif <- -log10(results_PP$FDR)
plot(results_PP$logFC,signif,pch=16)
points(results_PP[detags,"logFC"],-log10(results_PP[detags,"FDR"]),pch=16,col="red")

```

### Para o subtipo TRU

```{r}

lrt.BvsL = glmLRT(fit, coef = 3) 

topTags(lrt.BvsL)

```

-   Resultados e visualização destes

```{r}
results_TRU <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results_TRU
dim(results_TRU)
summary(de <- decideTestsDGE(lrt.BvsL))
```

Os resultados apresentam a associação entre o subtipo TRU do adenocarcinoma do pulmão e a expressão genética de diferentes genes.

Ao analisar os resultados, observamos que diversos genes, por exemplo, o gene ENSG00000073756.12 (PTGS.2) apresenta uma diminuição significativa na expressão no subtipo TRU, com um valor de P muito baixo, indicando uma forte associação estatística.

De seguida, criou-se um gráfico de dispersão dos valores de log fold-change em relação à média de contagens para cada gene, destacando os genes diferencialmente expressos identificados.

```{r}

detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)

```

Foi ainda criado um volcano plot onde os genes diferencialmente expressos identificados pelo teste são destacados em vermelho.

```{r}

signif <- -log10(results_TRU$FDR)
plot(results_TRU$logFC,signif,pch=16)
points(results_TRU[detags,"logFC"],-log10(results_TRU[detags,"FDR"]),pch=16,col="red")

```

# Análise de Enriquecimento

A análise de enriquecimento é realizada sobre o conjunto de genes alvo, identificados através da análise de expressão diferencial. O conjunto de genes identificados é comparado com outros conjuntos de genes, onde cada um destes contém genes biologicamente coerentes.

Assim, foram realizadas duas análises de enriquecimento, uma para o conjunto de genes alvo do coeficiente "exprprox.-inflam" e outra para o conjunto de genes alvo do coeficiente "exprTRU", onde seguimos este pipeline: <https://biostatsquid.com/fgsea-tutorial-gsea/>.

Para ser possível realizar a análise recorremos às seguintes funções retiradas e adaptadas da mesma fonte.

## Funções necessárias

```{r}
# Function: Adjacency matrix to list -------------------------
matrix_to_list <- function(pws){
  pws.l <- list()
  for (pw in colnames(pws)) {
    pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
  }
  return(pws.l)
}
## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE){
  # for debug
  #file <- gmt_files[1]
  #genes_in_data <- df$gene_symbol
  
  # Read in gmt file
  gmt <- gmtPathways(gmt_file)
  hidden <- unique(unlist(gmt))
  
  # Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
  mat <- matrix(NA, dimnames = list(hidden, names(gmt)),
                nrow = length(hidden), ncol = length(gmt))
  for (i in 1:dim(mat)[2]){
    mat[,i] <- as.numeric(hidden %in% gmt[[i]])
  }
  
  #Subset to the genes that are present in our data to avoid bias
  hidden1 <- intersect(genes_in_data, hidden)
  mat <- mat[hidden1, colnames(mat)[which(colSums(mat[hidden1,])>5)]] # filter for gene sets with more than 5 genes annotated
  # And get the list again
  final_list <- matrix_to_list(mat) # for this we use the function we previously defined
  
  if(savefile){
    saveRDS(final_list, file = paste0(gsub('.gmt', '', gmt_file), '_subset_', format(Sys.time(), '%d%m'), '.RData'))
  }
  
  #print('Wohoo! .gmt conversion successfull!:)') # optional
  return(final_list)
}
```

## Tratamento dos resultados obtidos através da análise de expressão diferencial

Posteriormente realizamos uma série de alterações aos resultados da análise de expressão diferencial de modo a obter o data frame com os resultados da análise de expressão diferencial, com os gene symbols como ids dos genes (linhas), ao invés dos ensembl ids. No entanto, neste processo alguns ensembl ids não conseguiram ser convertidos em gene symbols, ficando a coluna com missing values. Uma possível melhoria ao trabalho seria resolver este problema, que torna a análise mais difícil caso os genes com missing ids tenham uma expressão diferencial significativa. Os resultados da análise de expressão diferencial após este tratamento ficaram armazenados nas variáveis results_PP_mod e results_TRU_mod.

```{r}
# First, convert the row names to a new column
results_PP$row_names <- rownames(results_PP)
results_TRU$row_names <- rownames(results_TRU)

# Now, rearrange the columns so that the 'row_names' column comes first
results_PP_mod <- results_PP[, c("row_names", names(results_PP)[-ncol(results_PP)])]
results_TRU_mod <- results_TRU[, c("row_names", names(results_TRU)[-ncol(results_TRU)])]

# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"

# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
results_PP_mod$row_names <- sub("\\..*", "", results_PP_mod$row_names)
results_TRU_mod$row_names <- sub("\\..*", "", results_TRU_mod$row_names)

print(results_PP_mod)
print(results_TRU_mod)

#Variável

my_genes_PP = results_PP_mod$row_names
my_genes_TRU = results_TRU_mod$row_names

# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id_PP <- grch38 %>%
  filter(ensgene %in% results_PP_mod$row_names) %>%
  # Select only the 'entrez' column
  select(symbol)
resultados_id_TRU <- grch38 %>%
  filter(ensgene %in% results_TRU_mod$row_names) %>%
  # Select only the 'entrez' column
  select(symbol)

resultados_ensembl_id_PP <- grch38 %>%
  filter(ensgene %in% results_PP_mod$row_names) %>%
  # Select both 'ensgene' and 'symbol' columns
  select(ensgene, symbol)
resultados_ensembl_id_TRU <- grch38 %>%
  filter(ensgene %in% results_TRU_mod$row_names) %>%
  # Select both 'ensgene' and 'symbol' columns
  select(ensgene, symbol)

# Print the filtered table
print(resultados_id_PP)
print(resultados_id_TRU)

resultados_id_PP = as.data.frame(resultados_id_PP)
resultados_id_TRU = as.data.frame(resultados_id_TRU)

resultados_ensembl_id_PP
resultados_ensembl_id_TRU
```

```{r}
# Substituir os nomes das colunas "row_names" do dataframe "resultados_mod" pelos valores correspondentes da coluna "symbol" do dataframe "resultados_ensembl_id"
results_PP_mod$row_names <- resultados_ensembl_id_PP$symbol[match(gsub("\\..*", "", results_PP_mod$row_names), resultados_ensembl_id_PP$ensgene)]

results_TRU_mod$row_names <- resultados_ensembl_id_TRU$symbol[match(gsub("\\..*", "", results_TRU_mod$row_names), resultados_ensembl_id_TRU$ensgene)]

# Resultado final
print(results_PP_mod)
print(results_TRU_mod)
```

```{r}
# Remover os nomes das linhas do dataframe
rownames(results_PP_mod) <- NULL
rownames(results_TRU_mod) <- NULL

# Resultado final
print(results_PP_mod)
print(results_TRU_mod)
```

## Ranks

Depois procedemos a uma série de passos para preparar os valores dos "ranks" para serem usados na análise de enriquecimento. Os valores dos ranks para cada subtipo ficaram armazenados nas variáveis ranks_PP e ranks_TRU. Construímos também vários gráficos para analisar de uma forma global os valores dos ranks de cada gene.

```{r}
# ordenar os resultados por ordem decrescente dos valores da coluna "logFC"
results_PP.ord <- results_PP_mod[ order(-results_PP[,"logFC"]), ]
results_TRU.ord <- results_TRU_mod[ order(-results_TRU[,"logFC"]), ]

# somar um pseudo valor a resultados com valores de "logFC" iguais para permitir um desempate entre "logFC duplicados" e não surgirem problemas ao correr a função fgsea.
epsilon_PP <- runif(sum(duplicated(results_PP.ord$logFC)), min = 0, max = .001)
results_PP.ord$logFC[duplicated(results_PP.ord$logFC)] <- results_PP.ord$logFC[duplicated(results_PP.ord$logFC)] + epsilon_PP

epsilon_TRU <- runif(sum(duplicated(results_TRU.ord$logFC)), min = 0, max = .001)
results_TRU.ord$logFC[duplicated(results_TRU.ord$logFC)] <- results_TRU.ord$logFC[duplicated(results_TRU.ord$logFC)] + epsilon_TRU

# criar uma variável com todos os genes do dataset e os respetivos valores de "logFC"
ranks_PP <- results_PP.ord$logFC
ranks_TRU <- results_TRU.ord$logFC

names(ranks_PP) <- results_PP.ord$row_names
names(ranks_TRU) <- results_TRU.ord$row_names

head(ranks_PP)
head(ranks_TRU)

#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks_PP)
plot(ranks_TRU)

barplot(ranks_PP)
barplot(ranks_TRU)
```

Analisando estes gráficos verificamos que tanto entre os subtipos PP-PI como entre os subtipos TRU-PI existe um número relativamente elevado de genes com expressão diferencial potencialmente significativa, tanto valores "upregulated" (positivos) como "downregulated" (negativos). No entanto a grande maioria dos genes têm valores de rank próximos de 0, indicando pouca ou nenhuma expressão diferencial, o que seria expectável, pois entre dois subtipos da mesma doença grande parte dos genes terão uma expressão semelhante. Estes valores dos ranks foram obtidos a partir da variável "logFC", logo na realidade o que estamos a observar são os diferentes valores de "logFC" para todos os genes do dataset, ou seja, a razão entre as expressões dos genes nas condições PI - PP e TRU - PP, respetivamente. Isto permite-nos concluir que o nosso dataset parece ter vários genes cuja expressão diferencial é significativa. Contudo para verificar efetivamente se essa expressão é significativa iremos realizar uma análise mais profunda.

Posteriormente, carregamos os ficheiros .gmt contento os gene sets usados para a análise de enriquecimento, sendo que optamos por escolher os "hallmark gene sets" humanos, por estarem inerentemente ligados ao cancro.

```{r}
vector_PP = unlist(resultados_id_PP)
vector_TRU = unlist(resultados_id_TRU)

# Carregar ficheiro gmt
setwd('../')
# Nota: Necessário fornecer o caminho com a localização do ficheiro

#bg_genes_PP = prepare_gmt("~/h.all.v2023.2.Hs.symbols.gmt", vector_PP, savefile = #FALSE)
bg_genes_PP = prepare_gmt("./gene_sets/h.all.v2023.2.Hs.symbols.gmt", vector_PP, savefile = FALSE)


#bg_genes_TRU = prepare_gmt("~/h.all.v2023.2.Hs.symbols.gmt", vector_TRU, savefile #= FALSE)

bg_genes_TRU = prepare_gmt("./gene_sets/h.all.v2023.2.Hs.symbols.gmt", vector_TRU, savefile = FALSE)
```

Procedemos a algumas correções aos valores dos genes com pvalues demasiado baixos para evitar problemas com a função fgsea.

```{r}
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea

max_ranking_PP <- max(ranks_PP[is.finite(ranks_PP)])
min_ranking_PP <- min(ranks_PP[is.finite(ranks_PP)])
rankings_PP <- replace(ranks_PP, ranks_PP > max_ranking_PP, max_ranking_PP * 10)
rankings_PP <- replace(ranks_PP, ranks_PP < min_ranking_PP, min_ranking_PP * 10)
rankings_PP <- sort(ranks_PP, decreasing = TRUE) # sort genes by ranking

max_ranking_TRU <- max(ranks_TRU[is.finite(ranks_TRU)])
min_ranking_TRU <- min(ranks_TRU[is.finite(ranks_TRU)])
rankings_TRU <- replace(ranks_TRU, ranks_TRU > max_ranking_TRU, max_ranking_TRU * 10)
rankings_TRU <- replace(ranks_TRU, ranks_TRU < min_ranking_TRU, min_ranking_TRU * 10)
rankings_TRU <- sort(ranks_TRU, decreasing = TRUE) # sort genes by ranking
```

Construímos gráficos para avaliar os "ranks" dos primeiros 50 genes de cada suptipo, no entanto, mudando a gama de genes incluída no código podemos ver outros conjuntos de genes.

```{r}
# rankings of first 50 genes for the "exprprox.-inflam" coefficient
ggplot(data.frame(gene_symbol = names(ranks_PP)[1:50], ranks = ranks_PP[1:50]), aes(gene_symbol, ranks)) + 
	geom_point() +
	theme_classic() + 
	theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r}
# rankings of first 50 genes for the "exprTRU" coefficient
ggplot(data.frame(gene_symbol = names(ranks_TRU)[1:50], ranks = ranks_TRU[1:50]), aes(gene_symbol, ranks)) + 
	geom_point() +
	theme_classic() + 
	theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

## Correr o fgsea

De seguida realizamos a análise de enriquecimento propriamente dita, correndo a função fgsea, terminando esta parte com a construção de um gráfico com os pathways com valores significativos, filtrando os pathways com pvalues ajustados (padj) \< 0.05. O gráfico também contém os valores dos Normalized Enrichment Scores (NES) e dos pvalues não ajustados (pval) para cada pathway.

```{r}
# Run fgsea
fgseaRes_PP <- fgsea(pathways = bg_genes_PP, 
                  stats = rankings_PP,
                  scoreType = 'std',
                  minSize=15, 
                  maxSize = 500)
class(fgseaRes_PP)
dim(fgseaRes_PP)
head(fgseaRes_PP[order(padj), ])
sum(fgseaRes_PP[, padj < 0.05]) # number of significant pathways
```

```{r}
# plot top pathways for the "exprprox.-inflam" coefficient
topPathwaysUp_PP <- fgseaRes_PP[ES > 0][head(order(padj), n = 25), pathway]
topPathwaysDown_PP <- fgseaRes_PP[ES < 0][head(order(padj), n = 5), pathway]
topPathways_PP <- c(topPathwaysUp_PP, rev(topPathwaysDown_PP))

plotGseaTable(bg_genes_PP[topPathways_PP], stats = rankings_PP, fgseaRes = fgseaRes_PP, gseaParam = 0.5)
```

Analisando o gráfico para o coeficiente "exprprox.-prolif" verificamos que foram filtrados 10 pathways, sendo portanto os únicos com expressão diferencial significativa. Desses 10, os últimos 5 pathways apresentam p-values bastante menores, indicando uma maior expressão diferencial. Além disso, todos estes 5 apresentam valores de NES negativos, o que significa que estão downregulated relativamente à condição "exprprox.-inflam". Os primeiros 5 estão upregulated em relação à mesma condição. Também é possível reparar que um dos pathways downregulated é o pathway da resposta inflamatória, o que seria de esperar visto que está a ser comparado o subtipo Proximal Proliferative (PP) com o Proximal Inflamatory (PI), logo seria de esperar que o PI tivesse uma expressão muito superior dos genes deste pathway.

```{r}
# Run fgsea
fgseaRes_TRU <- fgsea(pathways = bg_genes_TRU, 
                  stats = rankings_TRU,
                  scoreType = 'std',
                  minSize=15, 
                  maxSize = 500)
class(fgseaRes_TRU)
dim(fgseaRes_TRU)
head(fgseaRes_TRU[order(padj), ])
sum(fgseaRes_TRU[, padj < 0.05]) # number of significant pathways
```

```{r}
# plot top pathways for the "exprTRU" coefficient
topPathwaysUp_TRU <- fgseaRes_TRU[ES > 0][head(order(padj), n = 25), pathway]
topPathwaysDown_TRU <- fgseaRes_TRU[ES < 0][head(order(padj), n = 5), pathway]
topPathways_TRU <- c(topPathwaysUp_TRU, rev(topPathwaysDown_TRU))

plotGseaTable(bg_genes_TRU[topPathways_TRU], stats = rankings_TRU, fgseaRes = fgseaRes_TRU, gseaParam = 0.5)
```

Analisando o gráfico para o coeficiente "exprTru" verificamos que este contém mais pathways filtrados (significativos), 19 para ser mais preciso. Novamente apenas os 5 últimos têm p-values muito mais pequenos e valores de NES negativos, indicando que estão downregulated também em relação ao coeficiente "exprprox.-inflam", no entanto, apenas os 3 últimos se mantêm quando comparados com o gráfico anterior. Novamente verificamos da mesma forma a questão do pathway da resposta inflamatória.

Finalmente, construímos um último gráfico para cada coeficiente, onde se visualiza o enrichment score (ES) em função dos ranks para o pathway com expressão diferencial mais significativa, permitindo analisar quais os ranks mais diferencialmente expressos para este pathway. Além disso, os gráficos poderiam ser adaptados para visualizar o mesmo, mas para outros pathways com expressão diferencial significativa.

```{r}
# plot the most significantly enriched pathway for the "exprprox.-inflam" coefficient
plotEnrichment(bg_genes_PP[[head(fgseaRes_PP[order(padj), ], 1)$pathway]],
               rankings_PP) + 
  labs(title = head(fgseaRes_PP[order(padj), ], 1)$pathway)
```

```{r}
# plot the most significantly enriched pathway for the "exprTRU" coefficient
plotEnrichment(bg_genes_TRU[[head(fgseaRes_TRU[order(padj), ], 1)$pathway]],
               rankings_TRU) + 
  labs(title = head(fgseaRes_TRU[order(padj), ], 1)$pathway)
```

# Redução de dimensionalidade

A técnica de redução de dimensionalidade, através da "Principal Component Analysis" (PCA), visa simplificar conjuntos de dados extensos, encontrando um conjunto menor de variáveis não correlacionadas que capturam a maior parte da variabilidade. Isso é alcançado através da transformação das variáveis originais em componentes principais, que são ordenados pela sua capacidade de explicar a variabilidade dos dados. Esta técnica é valiosa quando há muitas variáveis e potencial redundância nos dados, mas é importante normalizar os dados antes da análise para garantir resultados adequados.

Em primeiro lugar, foi instalado mais um package que auxiliará na visualizaçao dos resultados da PCA.

```{r}

#install.packages("factoextra")

```

```{r}

library(factoextra) # For PCA functions and visualizations

```

De seguida, o conjunto de dados utilizado no PCA foi redimensionado uma vez que esta técnina é sensível à escala das variáveis. Foi feita uma padronização para que os dados tenham uma média de 0 e um desvio padrão de 1.

```{r}
data_escala = scale(seqdata_filter) 

```

Uma vez que a função "prcomp" espera que as colunas sejam genes e as linhas as amostras, temos de efetuar a transporta da matriz do nosso dataset.

```{r}
pca = prcomp(t(data_escala), scale = TRUE)
```

```{r}
fviz_eig(pca)
```

StatQuest: PCA in R (youtube.com)

The first PC accounts for the most variation in the original data (the gene expression across all samples) and the 2nd PC account for the second most variation.

```{r}
plot(pca$x[,1], pca$x[,2])
```

Vamos agora averiguar quanta variação é que cada PC representa.

Em primeiro lugar usamos o quadrado de sdev, desvio padrão, para calcular a quantidade de variação que cada componente principal (PC) representa. Uma vez que a percentagem de cada quantidade de variação em cada PC é mais interessante que o próprio valor, vamos observar esses resultados aravés de uma gráfico de barras.

```{r}

pca_var = pca$sdev^2

pca_var_per = round(pca_var/sum(pca_var)*100, 1)

barplot(pca_var_per[1:20], main = "Scree Plot", xlab = "Componente Principal (PC)", ylab = "Variação Percentual")
```

Conseguimos perceber que os dois primeiros PCs contêm a variação de todo o dataset, sendo que o PC1 contêm quase toda a variação dos dados.

De seguida, procedemos à análise com o uso do package ggplot2.

```{r}

#Formatação dos dados
pca_data = data.frame(Sample=rownames(pca$x), X = pca$x[,1], Y = pca$x[,2])

pca_data
```

```{r}

ggplot(data = pca_data, aes (x = X, y = Y, label = Sample)) +
  geom_text() +
  xlab(paste("PC1 - ", pca_var_per[1], "%", sep = "")) + 
  ylab(paste("PC2 - ", pca_var_per[2], "%", sep = "")) +
  theme_bw() + 
  ggtitle("Gráfico PCA")

```

Next, we look into the loading scores of PC1 since it accounts for about 80% of the variation in the data. Let's look at the magnitude by using the function abs(), since genes that push samples to the left side of the graph have large negative values and genes that push to the right side of the graph have postive values

```{r}
loading_scores = pca$rotation[,1]

gene_scores = abs(loading_scores)

gene_score_ranked = sort(gene_scores, decreasing = TRUE)

top_10_genes = names(gene_score_ranked[1:10])

top_10_genes
```

```{r}
pca$rotation[top_10_genes,1]
```

They all push to the left.

```{r}
biplot(pca)
```

```{r}
plot(pca$x[,1], pca$x[,2], pch 
= 16, xlab = "PC1", ylab = "PC2")
```

```{r}
pca2 = princomp(scale(data_escala))
```

```{r}
plot(pca2)
```

```{r}
# Libs usadas - remover mais tarde
library(caret)
```

# Previsão de fenótipo utilizando aprendizagem automática

Nesta secção pretende-se explorar várias abordagens de aprendizagem automática para prever o fenótipo do carcinoma com base no perfil de expressão genética. Iremos testar um conjunto alargado de modelos de modo a aferir qual o que será mais adequado. Para este processo iremos seguir uma pipeline de aprendizagem automática simples, com recurso à biblioteca `caret`, que simplifica o procedimento de treino uma vez que faz o *wrapping* de várias funções e facilita a paremetrização.

Irão ser testados os seguintes modelos:

-   **Random Forests**: O modelo de aprendizagem automática com recurso a [random forests](https://www.sciencedirect.com/topics/engineering/random-forest) é um modelo de classificação que implementa um conjunto de árvores de decisão. O modelo sustenta-se na análise e classificação de dados com base em padrões. Este parece ser um modelo adequado para a identificação de fenótipos de cancro com base em perfis de expressão genética e pode ser um potencial modelo adequado para os nossos dados atendendo aos padrões claramente visíveis na representação dos dados por *heatmap*. Este modelo já foi inclusive corretamente implementado na previsão de fenótipos de cancro por Wang et al.
-   **Multi-Layer Perceptron (MLP)**: Um [MLP](https://www.sciencedirect.com/topics/veterinary-science-and-veterinary-medicine/multilayer-perceptron) é um tipo de [rede neuronal](https://www.sciencedirect.com/topics/social-sciences/neural-network) communmente utilizado na classificação de dados com base em padrões. Com base no seu funcionamento e lógica de utilização, poderá ter um desempenho interessante e adequado para o tipo de dados que estamos a analisar.

```{r}
#ML tests

# Inspirado nisto: https://www.sciencedirect.com/science/article/pii/S0307904X23002809
```

## Preparação de dados para análise

Para esta análise iremos partir dos perfis de variabilidade de expressão previamente definidos ordenados. Contudo, de modo a podermos testar os modelos de forma mais exaustiva não nos iremos cingir apenas aos 100 genes com maior variablidade de expressão mas sim em diferentes conjuntos, nomeadamente os "tops" 100, 500, 5000, 1000 e 10000 .

**NOTA**: De modo a facilitar a execução das células de código deste notebook iremos utilizar modelos pré-treinados com os parâmetros em comentário. Os modelos foram treinados por nós e gravados em formato ".rds". Em todo o caso apresentamos toda a pipeline seguida para os modelos mais pequenos.

### Criação de novas vistas

De modo a facilitar a visualização e ter uma visão de um possível comportamento do modelo, criamos vários **heatmaps** para cada uma das amostras.

```{r}
# Cálculo da variância de cada gene nos dados de contagem logaritmizada
var_genes       = apply(logcounts, 1, var)
var_genes.100   = apply(logcounts, 1, var)
var_genes.500   = apply(logcounts, 1, var)
var_genes.1000  = apply(logcounts, 1, var)
var_genes.5000  = apply(logcounts, 1, var)
var_genes.10000 = apply(logcounts, 1, var)

# Seleção dos 10 genes com maior variabilidade
select_var       = names(sort(var_genes, decreasing=TRUE))
select_var.100   = names(sort(var_genes, decreasing=TRUE))[1:100]
select_var.500   = names(sort(var_genes, decreasing=TRUE))[1:500]
select_var.1000  = names(sort(var_genes, decreasing=TRUE))[1:1000]
select_var.5000  = names(sort(var_genes, decreasing=TRUE))[1:5000]
select_var.10000 = names(sort(var_genes, decreasing=TRUE))[1:10000]

# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'
highly_variable_lcpm       = logcounts[select_var,]
highly_variable_lcpm.100   = logcounts[select_var.100,]
highly_variable_lcpm.500   = logcounts[select_var.500,]
highly_variable_lcpm.1000  = logcounts[select_var.5000,]
highly_variable_lcpm.5000  = logcounts[select_var.1000,]
highly_variable_lcpm.10000 = logcounts[select_var.10000,]
```

Conforme podemos visualizar nos heatmaps, há uma clara distinção para os diferentes perfis de expressão e respetivos fenótipos, pelo que é plausível considerar que os modelos serão bem sucedidos nas suas previsões de fenótipo. Contudo, importa salientar que os dados analisados são relativamente poucos (248 linhas apenas) o que, mesmo utilizando técnicas como validação cruzada e / ou *bootstrapping*, poderá levar a resultados enviesados e pouco satisfatórios.

```{r}
# Visualização de mapas para diferentes perfis para ter uma percepção de possíveis resultados

mypalette = RColorBrewer::brewer.pal(9,"RdYlBu")
morecols = colorRampPalette(mypalette)

# Todos

labels = levels(expr)
col.cell2 = c("purple","orange", "green")[expr][1:50]
heatmap.2(highly_variable_lcpm[,1:50],
          col=rev(morecols(50)),
          trace="column",
          main="Top 10 genes mais variáveis entre 50 amostras aleatórias",
          ColSideColors=col.cell2,scale="row",
          margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta

# 100

labels = levels(expr)
col.cell2 = c("purple","orange", "green")[expr][1:50]
heatmap.2(highly_variable_lcpm.100[,1:50],
          col=rev(morecols(50)),
          trace="column",
          main="Top 10 genes mais variáveis entre 50 amostras aleatórias",
          ColSideColors=col.cell2,scale="row",
          margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta

# 500

labels = levels(expr)
col.cell2 = c("purple","orange", "green")[expr][1:50]
heatmap.2(highly_variable_lcpm.500[,1:50],
          col=rev(morecols(50)),
          trace="column",
          main="Top 10 genes mais variáveis entre 50 amostras aleatórias",
          ColSideColors=col.cell2,scale="row",
          margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta

# 1000

labels = levels(expr)
col.cell2 = c("purple","orange", "green")[expr][1:50]
heatmap.2(highly_variable_lcpm.1000[,1:50],
          col=rev(morecols(50)),
          trace="column",
          main="Top 10 genes mais variáveis entre 50 amostras aleatórias",
          ColSideColors=col.cell2,scale="row",
          margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta

# 5000

labels = levels(expr)
col.cell2 = c("purple","orange", "green")[expr][1:50]
heatmap.2(highly_variable_lcpm.5000[,1:50],
          col=rev(morecols(50)),
          trace="column",
          main="Top 10 genes mais variáveis entre 50 amostras aleatórias",
          ColSideColors=col.cell2,scale="row",
          margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta

# 10000

labels = levels(expr)
col.cell2 = c("purple","orange", "green")[expr][1:50]
heatmap.2(highly_variable_lcpm.10000[,1:50],
          col=rev(morecols(50)),
          trace="column",
          main="Top 10 genes mais variáveis entre 50 amostras aleatórias",
          ColSideColors=col.cell2,scale="row",
          margins = c(5, 12))
legend("left", legend=labels, fill=c("purple","orange","green")) # corrigir etiqueta

```

### Preparação das matrizes para treino

Para criar o conjunto de dados para o treino dos modelos precisamos primeiro de transpor a matriz de perfis de expressão e criar a variável-alvo, neste caso o fenótipo.

```{r}
# Preparar as amostras e o tipo
expr_data = t(highly_variable_lcpm)
phenotype = meta$expr
phenotype
expr_profiles = cbind(expr_data,phenotype)
expr_profiles = as.data.frame(expr_profiles)
```
## Treino dos modelos

Nos blocos de código abaixo realizamos o treino dos diferentes modelos para os diferentes conjuntos de dados supraindicados e iremos analisar a sua performance através da sua matriz de confusão, *recalling*, *accuracy*, precisão e F1 score. 

### Criação dos dados de treino e treino dos modelos

Começamos por particionar os dados, utilizando uma fração de 80% para treino e uma fração de 20% para testes, seguindo as boas práticas geralmente aceites no que respeita a aprendizagem automática (colocar referências).

```{r}
# Criação do training set
set.seed(100)
  
inTrain = createDataPartition(y = expr_profiles$phenotype , p = 0.8, list = F)
trainData = expr_profiles[inTrain,]
testData = expr_profiles[-inTrain,]
```
### Random forests

```{r}
# Top 100
#interv = 1:100

#luad.rf.100 = caret::train(
#  trainData[,1:100],
#  trainData$phenotype, 
#  method = c('rf'), 
#  trControl = trainControl(method = 'boot', number = 5), 
#  tuneLength = 5, 
#  preProc = c("center", "scale")
#  )
```

### Multi-Layer Perceptron (MLP)

````{r}
# Top 100
#interv = 1:100

#luad.mlp.100 = caret::train(
#  trainData[,interv],
#  trainData$phenotype, 
#  method = 'mlp', 
#  trControl = trainControl(method='cv',number='5')
#)

```
## Análise de Resultados

### Análise dos resultados do modeloe respetivas matrizes de confusão. 

```{r}
# Carregamento dos modelos pré-treinados
setwd('../')

# Random forests
luad.rf.100   = readRDS('./models/random_forests/luad.rf.100.rds')
luad.rf.500   = readRDS('./models/random_forests/luad.rf.500.rds')
luad.rf.1000  = readRDS('./models/random_forests/luad.rf.1000.rds')
luad.rf.5000  = readRDS('./models/random_forests/luad.rf.5000.rds')
luad.rf.10000 = readRDS('./models/random_forests/luad.rf.10000.rds')
luad.rf.19529 = readRDS('./models/random_forests/luad.rf.19529.rds')

# MLP
luad.mlp.100   = readRDS('./models/multilayer_perceptron/luad.mlp.100.rds')
luad.mlp.500   = readRDS('./models/multilayer_perceptron/luad.mlp.500.rds')
luad.mlp.1000  = readRDS('./models/multilayer_perceptron/luad.mlp.1000.rds')
luad.mlp.5000  = readRDS('./models/multilayer_perceptron/luad.mlp.5000.rds')
luad.mlp.10000 = readRDS('./models/multilayer_perceptron/luad.mlp.10000.rds')
luad.mlp.19529 = readRDS('./models/multilayer_perceptron/luad.mlp.19529.rds')
```

#### Random Forests
```{r}
# Resultados do modelo
luad.rf.100$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.rf.100 = predict(luad.rf.100,testData[,1:100])

# Geramos e analisamos a matriz de confusão
cm.rf.100 = caret::confusionMatrix(pred.rf.100, testData$phenotype)
cm.rf.100
cm.rf.100$overall
cm.rf.100$byClass
```

```{r}
# Resultados do modelo
luad.rf.500$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.rf.500 = predict(luad.rf.500,testData[,1:500])

# Geramos e analisamos a matriz de confusão
cm.rf.500 = caret::confusionMatrix(pred.rf.500, testData$phenotype)
cm.rf.500$overall
cm.rf.500$byClass
```

```{r}
# Resultados do modelo
luad.rf.1000$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.rf.1000 = predict(luad.rf.1000,testData[,1:1000])

# Geramos e analisamos a matriz de confusão
cm.rf.1000 = caret::confusionMatrix(pred.rf.1000, testData$phenotype)
cm.rf.1000
cm.rf.1000$overall
cm.rf.1000$byClass
```

```{r}
# Resultados do modelo
luad.rf.5000$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.rf.5000 = predict(luad.rf.5000,testData[,1:5000])

# Geramos e analisamos a matriz de confusão
cm.rf.5000 = caret::confusionMatrix(pred.rf.5000, testData$phenotype)
cm.rf.5000$overall
cm.rf.5000$byClass
```

```{r}
# Resultados do modelo
luad.rf.10000$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.rf.10000 = predict(luad.rf.10000,testData[,1:10000])

# Geramos e analisamos a matriz de confusão
cm.rf.10000 = caret::confusionMatrix(pred.rf.10000, testData$phenotype)
cm.rf.10000
cm.rf.10000$overall
cm.rf.10000$byClass
```

```{r}
# Resultados do modelo
luad.rf.19529$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.rf.19529 = predict(luad.rf.19529,testData[,1:19529])

# Geramos e analisamos a matriz de confusão
cm.rf.19529 = caret::confusionMatrix(pred.rf.19529, testData$phenotype)
cm.rf.19529$overall
cm.rf.19529$byClass
```
#### Multi-Layer Perceptron (MLP)

```{r}
# Resultados do modelo
luad.mlp.100$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.mlp.100 = predict(luad.mlp.100,testData[,interv])

# Geramos e analisamos a matriz de confusão
cm.mlp.100 = caret::confusionMatrix(pred.mlp.100, testData$phenotype)
cm.mlp.100
cm.mlp.100$overall
cm.mlp.100$byClass
```

```{r}
# Resultados do modelo
luad.mlp.500$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.mlp.500 = predict(luad.mlp.500,testData[,interv])

# Geramos e analisamos a matriz de confusão
cm.mlp.500 = caret::confusionMatrix(pred.mlp.500, testData$phenotype)
cm.mlp.500
cm.mlp.500$overall
cm.mlp.500$byClass
```

```{r}
# Resultados do modelo
luad.mlp.1000$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.mlp.1000 = predict(luad.mlp.1000,testData[,interv])

# Geramos e analisamos a matriz de confusão
cm.mlp.1000 = caret::confusionMatrix(pred.mlp.1000, testData$phenotype)
cm.mlp.1000
cm.mlp.1000$overall
cm.mlp.1000$byClass


```

```{r}
# Resultados do modelo
luad.mlp.5000$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.mlp.5000 = predict(luad.mlp.5000,testData[,interv])

# Geramos e analisamos a matriz de confusão
cm.mlp.5000 = caret::confusionMatrix(pred.mlp.5000, testData$phenotype)
cm.mlp.5000
cm.mlp.5000$overall
cm.mlp.5000$byClass
```

```{r}
# Resultados do modelo
luad.mlp.10000$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.mlp.10000 = predict(luad.mlp.10000,testData[,interv])

# Geramos e analisamos a matriz de confusão
cm.mlp.10000 = caret::confusionMatrix(pred.mlp.10000, testData$phenotype)
cm.mlp.10000
cm.mlp.10000$overall
cm.mlp.10000$byClass
```


```{r}
# Resultados do modelo
luad.mlp.19529$results

# Utilizamos o modelo de inferência no conjunto de testes
pred.mlp.19529 = predict(luad.mlp.19529,testData[,interv])

# Geramos e analisamos a matriz de confusão
cm.mlp.19529 = caret::confusionMatrix(pred.mlp.19529, testData$phenotype)
cm.mlp.19529
cm.mlp.19529$overall
cm.mlp.19529$byClass
```

### Discussão

Ao analisar os resultados obtidos concluímos que o modelo de random forests é o modelo com melhores resultados, obtendo sempre uma precisão de 100% na classificação de amostras ao fenótipo correspondente. Contudo, estes resultados são algo suspeitos pois não é plausível existir um modelo que acerte 100% dos casos, mesmo com a aplicação de técnicas de validação cruzada e bootstrapping. Estes resultados podem estar relacionados com o facto de o conjunto de dados que estamos a utilizar não ser grande o suficiente. Seria interessante portanto utilizar um conjunto de dados mais extenso e voltar a testar e treinar os modelos. 

Já para os resultados do modelo MLP, vemos que este apresenta uma precisão de 100% para os "top" 100, 500 e 1000 entrando depois em decrescimo à medida que vamos tendo maior número de genes nos perfis. É de notar, no entanto, que a performance do modelo para 10000 genes é superior à performance para 5000 genes, o que pode representar que podem haver bastantes semelhanças nos top 5000 genes já haver fatores mais discrepantes quando voltamos a ter uma maior variabilidade de genes. Todavia este já é um comportamento mais ajustado à realidade, sobretudo sendo que o maior elemento de confusão está entre os tipos TRU e prox.-prolif que, através da análise dos heatmaps, podemos verificar que são os que apresentam os perfis de expressão mais similares.

**SUGESTÃO PARA VEREM SE CONCORDAM**: Consideraria que o MLP não é o mais adequado, atendendo ao tipo de modelo, mas ainda assim demonstra uma performance satisfatória, tendo obtido uma precisão média na ordem dos 75%.



```{r}
# Exemplo de código usado para guardar os modelos

#saveRDS(luad.rf.100, file = 'luad.rf.100.rds')
```



# Bibliografia

\bibliography{referencias}
