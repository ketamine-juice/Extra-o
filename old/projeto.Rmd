---
title: "Análise de Expressão Diferencial"
output:
  html_document:
    toc: yes
    toc_depth: 2
    toc_float: yes
    theme: spacelab
    number_sections: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
---

```{=html}
<style>
  body {text-align:justify}
</style>
```
# 1. Apresentação dos dados

O trabalho utiliza dados recolhidos a cabo do programa The Cancer Genome Atlas (TCGA) relacionado com adenocarcinoma do pulmão, disponibilizados através do Genomic Data Commons (GDC). A decisão de utilizar os dados do GDC foi influenciada pela sua curadoria completa, que inclui diversas amostras e dados clínicos sólidos. Adicionalmente, a existência de documentação e pacotes R para interface com a API GDC foram também fatores decisivos para esta escolha para análise de expressão diferencial utilizando edgeR.

## 1.1 Bibliotecas utilizadas

**Manifesto: Facilitando o Caminho para a Análise da Expressão Diferencial**

Para esta análise de expressão diferencial com edgeR utilizamos as seguintes bibliotecas:

-   **edgeR**: Uma ferramenta para análise de dados de RNA-seq, oferecendo métodos estatísticos avançados para identificar genes diferencialmente expressos.

-   **limma**: Reconhecido por sua flexibilidade e robustez, o limma é amplamente utilizado para análise de microarrays e RNA-seq, oferecendo uma variedade de modelos estatísticos.

-   **Glimma**: Essencial para visualização interativa de resultados de análise de expressão diferencial, o Glimma permite explorar e entender melhor os dados por meio de gráficos informativos.

-   **gplots**: Um pacote que oferece uma variedade de funções gráficas para visualização de dados, complementando as análises estatísticas.

-   **org.Mm.eg.db**: Uma base de dados essencial para mapeamento de identificadores de genes entre diferentes sistemas de anotação.

-   **RColorBrewer**: Oferece uma ampla seleção de paletas de cores para visualização de dados, tornando as figuras mais atraentes e informativas.

-   **TCGAbiolinks**: Fundamental para acesso e análise de dados do Projeto de Carcinoma Humano (TCGA), permitindo insights valiosos sobre uma variedade de tipos de câncer.

```{r instalar-packages}

  ## edgeR

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("edgeR")


  ## limma 

#BiocManager::install("limma")


  ## Glimma

#BiocManager::install(c("Glimma"))


  ##gplots

#BiocManager::install(c("gplots"))


  ##org.Mm.eg.db

#BiocManager::install(c("org.Mm.eg.db"))


  ##RColorBrewer

#BiocManager::install(c("RColorBrewer"))

  
  ##biomaRt

#BiocManager::install(c("biomaRt"))

  ##GSEABase

#BiocManager::install(c("GSEABase"))

  ##fgsea

#BiocManager::install(c("fgsea"))


  ##TCGAbiolinks

#if (!requireNamespace("TCGAbiolinks", quietly = TRUE))
#  BiocManager::install("TCGAbiolinks")

  ##clusterProfiler

#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("clusterProfiler")

  #Package para conversão de Ensembl para Gene ID
#install.packages("devtools")
#devtools::install_github("stephenturner/annotables")

```

De seguida, foi efetuado o carregamento das bibliotecas que haviam sido instaladas.

```{r carregar-packages}
suppressMessages({
  library(edgeR)
  library(limma)
  library(Glimma)
  library(gplots)
  library(org.Mm.eg.db)
  library(RColorBrewer)
  library(TCGAbiolinks)
  library(SummarizedExperiment)
  library(biomaRt)
  library(GSEABase)
  library(fgsea)
  library(clusterProfiler)
  library(ggplot2)
  library(dplyr)
  library(annotables)
})

```

# 2. Carregamento e pré-processamento dos dados

## 2.1. Transferência e carregamento dos ficheiros necessários

Para a transferência do dataset do conjunto de dados de expressão genética, utilizou-se o pacote TCGAbiolinks, que é uma ferramenta que permite aceder e descarregar dados do The Cancer Genome Atlas (TCGA). Na query, definimos a procura específica dos dados do projeto TCGA-LUAD, a categoria dos mesmos é do tipo "Perfil do Transcriptoma" e a estratégia experimental utilizada para gerar esses dados é a RNA-Seq. Os dados foram processados utilizando o algoritmo STAR para alinhamento de sequências, resultando em contagens de leitura para cada gene. Portanto, o parâmetro "workflow.type" foi especificado como "STAR - Counts". Por fim, especificamos que queremos ter acesso aos dados que estão disponíveis publicamente através do parâmetro "access".

Após a transferência dos dados é então gerado um objeto `summarizedExperiment` através do código GDCprepare. Utilizam-se parâmetros para gravar os dados para simplificar o carregamento do objeto posteriormente, caso seja necessário.

```{r transferencia-dados}
luad = GDCquery( 
  project = "TCGA-LUAD",
  data.category = "Transcriptome Profiling",
  experimental.strategy = 'RNA-Seq',
  workflow.type = "STAR - Counts",
  access = "open"
)

# GDCdownload(luad)


```

## 2.2. Pré-processamento dos dados

Abaixo carregamos os dados transferidos do GDC via TCGAbiolinks utilizando o método GDCprepare, que processa automaticamente os ficheiros presentes na pasta GDCdata criada e os converte num objeto SummarizedExperiment que comporta um conjunto de tabelas com dados como expressão genética de vários genes para cada amostra e metadados associados a essas amostras.

```{r carregamento-dados}
# Carregamos os dados de expressão genética e dos metadados associados

# luad_data = GDCprepare(luad, 
#                       save = TRUE, 
#                       save.filename = 'luad_data_load.rda',
#                       summarizedExperiment = TRUE)

# Simplificado
luad_data = GDCprepare(luad)
```

```{r carregamento-dados}
# Alternativamente para quando o servidor está em baixo
luad_data = load('luad_data_load.rda')
luad_data = data
```


Abaixo procedemos a uma primeira verificação dos dados.

```{r verificacao-dados}
# Tamanho do objeto
dim(luad_data)

# Informação sobre o estudo
metadata(luad_data)

# Informação sobre os tipos de dados de RNASeq
names(assays(luad_data))

# Tipos de metadados associados a cada gene
names(rowData(luad_data))

# Tipos de metadados associados a cada amostra
names(colData(luad_data))

```

Através da informação fornecida em cima, conseguimos perceber que:

-   **dim** - O objeto tem 60660 linhas, cada uma representa um gene, e 600 colunas, que representam as amostras individuais, correspondendo ao especificado na [documentação do estudo](https://portal.gdc.cancer.gov/projects/TCGA-LUAD).

-   **metadata** - Os metadados indicam a data de lançamento dos dados.

-   **assays** - A informação obtida através dos assays dá-nos 6 tipos de dados tendo em consideração a orientação dos transcritos obtidos e diferentes tipos de normalização.

-   **rownames** - Cada linha está rotulada com o ID de um gene no formato Ensembl.

-   **rowData names** - Existem 10 metadados associados a cada gene, incluindo, por exemplo, a "source", o "type" e o "score".

-   **colnames** - As colunas estão rotuladas com os códigos de barras (barcodes) das amostras, identificando cada amostra de forma única.

-   **colData names** - Há 89 metadados associados a cada amostra, que incluem, por exemplo, o estágio do tumor ("paper_Tumor.stage") e o género ("gender").

### 2.2.1. Preparação da estrutura de dados

Para chegar à estrutura desejável dos dados, realizou-se a transformação do dataset em dataframe a partir dos dados em bruto. Optou-se por extrair os dados de RNASeq correspondentes às contagens `unstranded` uma vez que a direção dos transcritos não é relevante para este trabalho.

```{r}

# Carregamento, extração e transformação dos dados provenientes do RNAseq 
seqdata = as.data.frame(assay(luad_data, 'unstranded'))

#Verificação da inexistência de valores NA
any(is.na(seqdata))

```

Foram também carregados os metadados, isolando os dados correspondentes à presença/ausência de oncogenes e os dados associados à variável "gender" na variável "meta".

```{r}

# Carregamento de metadados

sample_id = substr(luad_data$sample_id, 1, 10)

expr = luad_data$paper_expression_subtype

meta = data.frame(sample_id = sample_id, expr = expr)



```

De seguida, foi feita uma filtragem das colunas do dataframe `seqdata` para manter apenas as amostras que possuem informações sobre a presença/ausência de oncogenes com base nos metadados previamente tratados.

O resultado é armazenado na variável `seqdata_filter`, que conterá apenas as colunas de `seqdata` associadas a amostras com informações sobre os oncogenes. Esta variável servirá para, posteriormente, criar o objeto de análise de expressão genética.

```{r pre-processamento}

# Limpeza dos dados e tratamento relativo ao género


any(is.na(meta$expr))

meta = meta[!is.na(meta$expr),]

table(meta$expr)

filter = meta$expr != '[Not Available]'

meta = meta[filter,]


# Criar uma vista dos dados de RNASeq com base nos subtipos de expressão


seqdata_filter = seqdata[,meta$expr] 

```

Fazemos uma verificação final para garantir que os dados estão corretamente carregados e é feita a sua correspondência para garantir o correto encadeamento dos dados de expressão com as respetivas amostras.

```{r verficacao-final-dados}

# Garantir que as dims estão corretas

dim(seqdata_filter)

dim(meta)

# Corrigir nomes e garantir ordem 

colnames(seqdata_filter) = meta$sample_id

all(names(seqdata_filter) == meta$sample_id)

```

Como conseguimos observar, o número de colunas do dataframe "seqdata_filter" é igual ao número de linhas do dataframe "meta".

## 2.3. Análise exploratória (NÃO SEI SE É BOM TÍTULO)

Neste processo, os dados de expressão genética são refinados antes da análise. Primeiro, é efetuado o cálculo das Contagens Por Milhão (CPM), uma métrica importante na normalização de dados de sequenciamento. Em seguida, os dados são ajustados para remover genes com expressão muito baixa, uma prática comum na análise de RNA-Seq. Este critério de remoção, definido como genes com CPM inferior a 0.5 em pelo menos duas amostras, é aplicado para manter apenas os genes mais relevantes. O número de genes excluídos é relatado para avaliação.

referencias para justificar CPM:

<https://www.frontiersin.org/journals/genetics/articles/10.3389/fgene.2020.00594/full#B32> <https://academic.oup.com/bioinformatics/article/26/1/139/182458?login=false>

```{r analise-exploratoria-pt1}
# Calculamos CPM
calccpm = cpm(seqdata_filter)

# Aparamos os dados, removendo genes com baixa expressão
# é geralmente aceite a eliminação de genes com CPM inferior a 0.5 em mais do que 2 amostras
thresh = calccpm > 0.5
keep = rowSums(thresh) >= 2
counts_keep = seqdata_filter[keep,]

summary(keep)

dim(counts_keep)

```

A analisar o sumário da variável `keep`, que corresponde aos genes que serão mantidos para análise, identificamos que serão desconsiderados **41 131** genes.

Posteriormente, os dados são organizados num objeto `dgeObj`, adequado para análise estatística de expressão diferencial, preparando-os para investigações mais aprofundadas sobre as variações na expressão genética entre as condições estudadas.

```{r analise-exploratoria-pt2}

# Criação do objeto para a análise de expr. diferencial

dgeObj = DGEList(counts_keep)

names(dgeObj)

head(dgeObj$samples)

```

De seguida, procedeu-se à logaritmização dos dados, uma prática comum no tratamento de dados de expressão genético para posterior análise da sua diferenciação. A logaritmização é essencial para reduzir o enviesamento dos dados.

Ao analisar os boxplots das contagens logaritmizadas, podemos identificar a presença de outliers que nos pode indicar a existência de genes sobreexpressos ou subexpressos. Esses outliers representam observações que estão significativamente distantes da maioria dos valores no conjunto de dados. No contexto da expressão genética, os outliers podem surgir devido a vários fatores, como erros experimentais, variações biológicas extremas ou mesmo artefatos técnicos durante a geração dos dados. Genes sobreexpressos, em particular, podem ser de interesse em estudos de expressão diferencial, uma vez que podem desempenhar papéis importantes em processos biológicos específicos ou estar associados a doenças. Portanto, a identificação e o entendimento dos outliers são cruciais para interpretar corretamente os resultados das análises de expressão genétca e para discernir padrões biologicamente relevantes das variações aleatórias nos dados.

```{r analise-exploratoria-pt3}

## distributions - log transform
logcounts = cpm(dgeObj,log=TRUE)


## Set up the connection to Ensembl
#ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
#ensembl_dataset <- useDataset('hsapiens_gene_ensembl', mart = ensembl)

# Remove version numbers from Ensembl gene IDs in logcounts
#ensembl_ids <- gsub("\\..*", "", rownames(logcounts))
#rownames(logcounts) <- ensembl_ids

# Retrieve gene symbols for the Ensembl IDs
#gene_symbols <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
#                      filters = "ensembl_gene_id",
#                      values = ensembl_ids,
#                      mart = ensembl)

# Loop through each Ensembl gene ID in seqdata
#for (i in seq_along(ensembl_ids)) {
  # Find the index of the Ensembl gene ID in gene_symbols
#  idx <- match(ensembl_ids[i], gene_symbols$ensembl_gene_id)
  # If a corresponding gene symbol is found and it's not an empty string, replace the row name
#  if (!is.na(idx) && gene_symbols$external_gene_name[idx] != "") {
#    rownames(logcounts)[i] <- gene_symbols$external_gene_name[idx]
#  }
#}


boxplot(logcounts[,1:50], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")

boxplot(logcounts[,51:100], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")


boxplot(logcounts[,101:150], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")


boxplot(logcounts[,151:200], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")

boxplot(logcounts[,201:248], xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")


```
```{r}
# Verifica se todas as linhas começam com "ENS"
all_ens <- all(grepl("^ENS", rownames(logcounts)))

# Se 'all_ens' for TRUE, significa que todas as linhas começam com "ENS"
if (all_ens) {
  cat("Todas as linhas começam com 'ENS'.\n")
} else {
  cat("Algumas linhas não começam com 'ENS'.\n")
}


```



Abaixo é feita a análise de expressão genética dos 10 genes com maior variabilidade detetada para a presença/ausência de oncogenes.

```{r}

# Cálculo da variância de cada gene nos dados de contagem logaritmizada

var_genes = apply(logcounts, 1, var)

# Seleção dos 10 genes com maior variabilidade

select_var = names(sort(var_genes, decreasing=TRUE))[1:10]

select_var

# Seleciona as linhas da matriz 'logcounts' com base nos índices fornecidos em 'select_var'

highly_variable_lcpm = logcounts[select_var,]

# Calcula as dimensões (número de linhas e colunas) da matriz 'highly_variable_lcpm'

dim(highly_variable_lcpm)


```

Para melhorar a visualização destas diferenças poderão ser empregues estratégias como a análise de PCA ou a agregação de amostras , permitindo uma compreensão mais clara das variações genéticas associadas aos estadios tumorais.

A identificação dos genes mais variáveis e a atribuição de cores com base nos estágios do tumor oferecem insights valiosos sobre a expressão genética diferencial entre os estadios do câncer, fornecendo pistas importantes sobre a progressão da doença e possíveis alvos terapêuticos.

```{r}

mypalette <- brewer.pal(9,"RdYlBu")

morecols <- colorRampPalette(mypalette)


col.cell1 = c("purple","orange", "green")[meta$expr]
heatmap.2(highly_variable_lcpm, 
          col=rev(morecols(50)),
          trace="column", 
          main="Top 10 most variable genes across samples",
          ColSideColors=col.cell1,scale="row")

```

Apesar do desafio imposto pelo grande número de amostras, esta análise exploratória revela diferenças notáveis entre estadios.

### 2.3.1. Normalização

A normalização dos dados de RNA-seq desempenha um papel crucial no processo de análise realizado pelo edgeR. Por meio do método de Trimmed Means of M-values (TMM), as contagens de leitura são ajustadas levando em consideração a composição global das amostras, o que corrige variações introduzidas durante o sequenciamento. Ao aplicar a função `calcNormFactors()`, o edgeR calcula os fatores de normalização (escala) com base na técnica TMM, assegurando uma correção adequada das diferenças observadas entre as amostras.

O código fornecido ilustra a aplicação desse processo ao objeto de dados `dgeObj`. Em seguida, são gerados gráficos de diferença de média versus média (MD) para visualizar o efeito da normalização nos dados. Esses gráficos permitem avaliar se as variações biológicas são mantidas após o ajuste das contagens, destacando a ausência de diferenças médias entre as amostras como referência para a eficácia da normalização.

Quando as diferenças observadas nos gráficos de MD antes e depois da normalização por TMM são mínimas, isso sugere que o impacto da normalização nas contagens de leitura é insignificante. Isso pode indicar que as variações técnicas introduzidas durante o sequenciamento já eram baixas ou que as amostras possuíam uma composição homogênea.

Embora isso sugira estabilidade nos dados, é importante ressaltar que pequenas diferenças podem ter relevância biológica. Portanto, é necessário interpretar os resultados com cautela, considerando outros aspectos do experimento, como o contexto biológico e as condições experimentais, para compreender plenamente o significado das variações observadas.

```{r}
dgeObj = calcNormFactors(dgeObj)

# demo

plotMD(logcounts, column = 7)
abline(h=0,col="grey")

plotMD(dgeObj, column = 7)
abline(h=0,col="grey")
```

```{r}
dgeObj
```


# 3. Análise de expressão diferencial e de enriquecimento

Para a análise de expressão diferencial agruparam-se duas variáveis com base em duas características selecionadas por nós: género e subtipo de expressão. Ao agrupar as amostras com base nessas características, podemos comparar os diferentes níveis de expressão de genes entre os dois tipos de género e os três subtipos de expressão, permitindo a identificação de genes cuja expressão está associada a essas características.

Assim, esta análise permitirá ganhar insights sobre a regulação genética subjacente às condições biológicas selecionadas

## 3.1. Agrupamento de variáveis

Em primeiro lugar, agruparam-se numa variável as duas variáveis selecionadas para a análise da expressão genética e, de seguida, coverteu-se a variável "group" para o tipo "caractér" para permitir futura compatibilidade com as operação efetuadas.

```{r}

# Substituir caracteres especiais nos valores de expr
meta$expr <- gsub("prox.-prolif.", "prox_prolif", meta$expr)
meta$expr <- gsub("prox.-inflam", "prox_inflam", meta$expr)

group = paste(meta$expr)

group = as.character(group)

group

```

## 3.2. Criação da matriz de design

A matriz de design expecifica o desenho experimental e as variáveis de interesse na análise de expressão diferencial.

Foram extraídas as variáveis de interesse, "gender_dge" e "expr_dge" e, de seguida, criada a matriz de design.

```{r}

# Definir a variável de design

design = model.matrix(~group)


head(design)

```

Podemos observar que foram excluídos dois níveis "male" e "prox.-prolif" A exclusão dos dois níveis das variáveis na matriz de design ocorreu porque, ao criar a matriz de design com a fórmula ~ expr + gender, o R utiliza o esquema de codificação dummy para representar variáveis categóricas. Esse esquema cria uma coluna para cada nível da variável categórica, exceto um, que serve como referência.

No caso de variáveis categóricas uma coluna é criada para cada nível único, exceto um, que é excluído para evitar redundância de informações. Portanto, o R exclui automaticamente um nível para evitar a redundância de informações na matriz de design.


## 3.3. Ajuste de model

Um dos passos mais importantes na análise de dados de expressão genética diferencial usando um modelo Binomial Negativo, como é o caso do edgeR, é a medição do grau de variação de cada gene. Ajustar o modelo, usando o pacote edgeR, envolve três passos. Em primeiro lugar, estima-se a variação comum, "estimateCommonDisp", que nos dá uma ideia da dispersão geral do genoma para o conjunto de dados selecionado.

<https://web.stanford.edu/class/bios221/labs/rnaseq/lab_4_rnaseq.html>

```{r}
dgeObj = estimateCommonDisp(dgeObj)

dgeObj$common.dispersion

```

Depois, é necessário ajustar um modelo de tendência que consiste na dispersão média entre todos os genes com abundância semelhante. Ou seja, é o valor ajustado da tendência da dispersão média.

```{r}
dgeObj = estimateGLMTrendedDisp(dgeObj)

```

Por último, foi calculada a dispersão "Tagwise".

```{r}
dgeObj = estimateTagwiseDisp(dgeObj)

```

Podemos observar a representação gráfica do coeficiente de variação biológica (BCV) do gene em função da abundância do gene (em log2 contagens por milhão).

```{r}
plotBCV(dgeObj)
```

O modelo NB pode ser alargado com métodos de quasi-likehood (QL) para ter em conta a variabilidade específica do gene de fontes biológicas e técnicas. O modelo NB descreve a variabilidade biológica global em todos os genes. Já os métodos QL, são capazes de descrever a variabilidade específica do gene acima e abaixo do nível global.

<https://rest.neptune-prod.its.unimelb.edu.au/server/api/core/bitstreams/3e89dfc8-449b-5463-a53d-7c10e31add5e/content>

A estimativa das dispersões de QL é efectuada utilizando a função glmQLFit. Esta função é utilizada para ajustar o modelo, e os resultados são armazenados na variável "fit":



```{r}

fit = glmFit(dgeObj, design)

head(fit$coefficients)

```

Devolveu um objeto DGEGLM com os valores estimados dos coeficientes GLM para cada gene.

Cada coeficiente representa a mudança esperada na expressão para um aumento unitário na respectiva variável independente, mantendo todas as outras variáveis constantes. Por exemplo:

- Um aumento unitário em "exprprox.-inflam" está associado a uma diminuição de 0.09420212 unidades na expressão genética do gene ENSG00000000003.15.
- Um aumento unitário em "exprTRU" está associado a um aumento de 0.4591496 unidades na expressão do gene ENSG00000000419.1.
- A variável "genderfemale" é uma variável binária, então o coeficiente representa a diferença na expressão genética entre indivíduos do sexo feminino e masculino. Neste caso, o coeficiente é muito próximo de zero, indicando que não há uma diferença significativa na expressão genética entre os dois géneros neste modelo.


## 3.4. Teste de Razão de Verossimilhança (LRT)

### 3.4.1 Para o coeficiente "exprprox.-inflam"


```{r}

lrt.BvsL = glmLRT(fit, coef = 2) 

topTags(lrt.BvsL)

```

-   Resultados e visualização destes

```{r}
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
```


A variável "exprprox.-inflam" representa a expressão genética de genes associados à ??????. Os resultados do teste de verossimilhança indicam:

- logFC: Reflete a magnitude da mudança na expressão genética desses genes em comparação com a média de todos os genes. Valores positivos significam aumento na expressão, enquanto negativos indicam diminuição.Os valores de logFC variam entre -9.728 e 10.289, indicando uma ampla gama de mudanças na expressão genética dos genes associados à ?????. Isso sugere que alguns genes têm uma expressão significativamente aumentada em resposta à ?????, enquanto outros têm uma expressão significativamente reduzida.

- PValue e FDR: Indicam a significância estatística dessas mudanças na expressão. Valores baixos sugerem que as mudanças são estatisticamente significativas.Todos os valores apresentados de PValue e FDR são muito próximos de zero, o que indica uma forte evidência estatística de que as mudanças observadas na expressão genética são significativas. Isso sugere que as diferenças na expressão dos genes associados à ??????? são altamente improváveis de ocorrerem ao acaso e são muito confiáveis.


Os genes foram classificados como "Up" (expressão aumentada), "Down" (expressão reduzida) ou "NotSig" (não significativo) em relação à inflamação. A maioria dos genes (8626) está classificada como "Up", indicando aumento da expressão em resposta à ?????????, enquanto 8428 genes estão classificados como "Down", indicando redução da expressão. Além disso, 2475 genes não mostram uma mudança significativa na expressão em resposta à ?????????.

De seguida, criou-se um gráfico de dispersão dos valores de log fold-change em relação à média de contagens para cada gene, destacando os genes diferencialmente expressos identificados.

```{r}

detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)

```

Foi ainda criado um volcano plot onde os genes diferencialmente expressos identificados pelo teste são destacados em vermelho.

```{r}

signif <- -log10(results$FDR)
plot(results$logFC,signif,pch=16)
points(results[detags,"logFC"],-log10(results[detags,"FDR"]),pch=16,col="red")

```


### 3.4.1 Para o coeficiente "exprTRU"


```{r}

lrt.BvsL = glmLRT(fit, coef = 3) 

topTags(lrt.BvsL)

```


-   Resultados e visualização destes

```{r}
results <- as.data.frame(topTags(lrt.BvsL,n = Inf))
results
dim(results)
summary(de <- decideTestsDGE(lrt.BvsL))
```

Com base nos resultados fornecidos para o coeficiente "exprTRU":

- logFC: Os valores de logFC variam entre -10.591 e 9.348, indicando uma ampla gama de mudanças na expressão genética dos genes associados à condição representada pela variável "exprTRU". Logo, sugere que alguns genes têm uma expressão significativamente aumentada em resposta a essa condição, enquanto outros têm uma expressão significativamente reduzida.

- PValue e FDR: Todos os valores de PValue e FDR são muito próximos de zero, indicando uma forte evidência estatística de que as mudanças observadas na expressão gênica são significativas. Isso sugere que as diferenças na expressão dos genes associados à condição representada por "exprTRU" são altamente improváveis de ocorrerem ao acaso e são muito confiáveis do ponto de vista estatístico.

Portanto, com base nos dados fornecidos, podemos concluir que há uma associação significativa entre a condição representada por "exprTRU" e a expressão genética dos genes estudados. Alguns genes têm sua expressão aumentada em resposta a essa condição, enquanto outros têm sua expressão reduzida, e essas mudanças são altamente confiáveis do ponto de vista estatístico.


EXPLORAR SIGNIFICADO BIOLÓGICO


De seguida, criou-se um gráfico de dispersão dos valores de log fold-change em relação à média de contagens para cada gene, destacando os genes diferencialmente expressos identificados.

```{r}

detags <- rownames(dgeObj)[as.logical(de)]
plotSmear(lrt.BvsL, de.tags=detags)

```

Foi ainda criado um volcano plot onde os genes diferencialmente expressos identificados pelo teste são destacados em vermelho.

```{r}

signif <- -log10(results$FDR)
plot(results$logFC,signif,pch=16)
points(results[detags,"logFC"],-log10(results[detags,"FDR"]),pch=16,col="red")

```

#### Análise de Enriquecimento

A análise de enriquecimento é realizada sobre o conjunto de genes alvo, identificados por através da análise de expressão diferencial. O conjunto de genes identificados é comparado com outros conjuntos de genes, onde cada um destes contém genes biologicamente coerentes

```{r}

head(dgeObj$samples)
```
## Funções necessárias

```{r}

matrix_to_list <- function(pws){
  pws.l <- list()
  for (pw in colnames(pws)) {
    pws.l[[pw]] <- rownames(pws)[as.logical(pws[, pw])]
  }
  return(pws.l)
}
## Function: prepare_gmt --------------------------------------
prepare_gmt <- function(gmt_file, genes_in_data, savefile = FALSE){
  # for debug
  #file <- gmt_files[1]
  #genes_in_data <- df$gene_symbol
  
  # Read in gmt file
  gmt <- gmtPathways(gmt_file)
  hidden <- unique(unlist(gmt))
  
  # Convert gmt file to a matrix with the genes as rows and for each go annotation (columns) the values are 0 or 1
  mat <- matrix(NA, dimnames = list(hidden, names(gmt)),
                nrow = length(hidden), ncol = length(gmt))
  for (i in 1:dim(mat)[2]){
    mat[,i] <- as.numeric(hidden %in% gmt[[i]])
  }
  
  #Subset to the genes that are present in our data to avoid bias
  hidden1 <- intersect(genes_in_data, hidden)
  mat <- mat[hidden1, colnames(mat)[which(colSums(mat[hidden1,])>5)]] # filter for gene sets with more than 5 genes annotated
  # And get the list again
  final_list <- matrix_to_list(mat) # for this we use the function we previously defined
  
  if(savefile){
    saveRDS(final_list, file = paste0(gsub('.gmt', '', gmt_file), '_subset_', format(Sys.time(), '%d%m'), '.RData'))
  }
  
  print('Wohoo! .gmt conversion successfull!:)')
  return(final_list)
}
```

## Aprimoramento dos resultados

```{r}
                ############ 1  ##############
# First, convert the row names to a new column
results$row_names <- rownames(results)

# Now, rearrange the columns so that the 'row_names' column comes first
resultados_mod <- results[, c("row_names", names(results)[-ncol(results)])]

# Optionally, you can rename the 'row_names' column if needed
# colnames(df)[1] <- "Row_List"

# Assuming 'df' is your dataframe and 'row_names' is the column containing row names
resultados_mod$row_names <- sub("\\..*", "", resultados_mod$row_names)

print(resultados_mod)

#Variável

my_genes = resultados_mod$row_names


# Filter 'grch38' based on 'row_names' from 'resultados_mod'
resultados_id <- grch38 %>%
  filter(ensgene %in% resultados_mod$row_names) %>%
  # Select only the 'entrez' column
  select(symbol)


resultados_ensembl_id <- grch38 %>%
  filter(ensgene %in% resultados_mod$row_names) %>%
  # Select only the 'entrez' column
  select(ensgene, symbol)

# Print the filtered table
print(resultados_id)

resultados_id = as.data.frame(resultados_id)

resultados_ensembl_id


```


```{r}
# Substituir os nomes das colunas "row_names" do dataframe "resultados_mod" pelos valores correspondentes da coluna "symbol" do dataframe "resultados_ensembl_id"
resultados_mod$row_names <- resultados_ensembl_id$symbol[match(gsub("\\..*", "", resultados_mod$row_names), resultados_ensembl_id$ensgene)]

# Resultado final
print(resultados_mod)
```


```{r}
# Remover os nomes das linhas do dataframe
rownames(resultados_mod) <- NULL

# Resultado final
print(resultados_mod)

```


## Ranks


```{r}

results.ord <- resultados_mod[ order(-results[,"logFC"]), ]

epsilon <- runif(sum(duplicated(results.ord$logFC)), min = 0, max = .001)
results.ord$logFC[duplicated(results.ord$logFC)] <- results.ord$logFC[duplicated(results.ord$logFC)] + epsilon

ranks <- results.ord$logFC
names(ranks) <- results.ord$row_names

head(ranks)

#ranks <- sort(ranks, decreasing = TRUE) # sort genes by ranking
plot(ranks)

barplot(ranks)

```


```{r}

vector = unlist(resultados_id)

#Carregar ficheiro gmt

bg_genes = prepare_gmt("C:\\Users\\olive\\Desktop\\Extracao\\c2.cp.v2023.2.Hs.symbols.gmt", vector, savefile = FALSE)
```


```{r}
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking <- max(ranks[is.finite(ranks)])
min_ranking <- min(ranks[is.finite(ranks)])
rankings <- replace(ranks, ranks > max_ranking, max_ranking * 10)
rankings <- replace(ranks, ranks < min_ranking, min_ranking * 10)
rankings <- sort(ranks, decreasing = TRUE) # sort genes by ranking
```


```{r}
fgseaRes <- fgsea(pathways = bg_genes, 
                  stats = rankings,
                  scoreType = 'std',
                  minSize=10, 
                  maxSize = 1000)
class(fgseaRes)
dim(fgseaRes)
head(fgseaRes[order(padj), ])
```


```{r}
ggplot(data.frame(gene_symbol = names(ranks)[1:50], ranks = ranks[1:50]), aes(gene_symbol, ranks)) + 
	geom_point() +
	theme_classic() + 
	theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```









